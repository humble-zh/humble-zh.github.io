<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>java学习1 Java零基础学习视频通俗易懂 | Zhihong&#39;s Blog</title>
    <meta name="author" content="Zhihong Li" />
    <meta name="keywords" content="zhbox" />
    <meta name="description" content="【狂神说Java】Java零基础学习视频通俗易懂HelloWorld123456789101112131415161718# li @ evpower in ~/humble/blog/source/_posts/java on git:master x [18:27:56]$ cat Hello.javapublic class Hello&amp;#123;    public static void main(String[] args)&amp;#123; System.out.print(&amp;quot;" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />

    
    <link rel="alternate" href="/atom.xml" title="Zhihong&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <style type="text/css">
    @font-face {
        font-family: 'icomoon';
        src: url("/fonts/icomoon.eot?q628ml");
        src: url("/fonts/icomoon.eot?q628ml#iefix") format('embedded-opentype'),
             url("/fonts/icomoon.ttf?q628ml") format('truetype'),
             url("/fonts/icomoon.woff?q628ml") format('woff'),
             url("/fonts/icomoon.svg?q628ml#icomoon") format('svg');
        font-weight: normal;
        font-style: normal;
    }
    </style>
    
<link rel="stylesheet" href="/css/style.css">


    <!--[if lt IE 9]><style type="text/css">.nav-inner {top:0;}.author-meta {position:static;top:0;}.search-form {height:36px;}</style><script type="text/javascript" src="https://unpkg.com/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
<meta name="generator" content="Hexo 5.3.0"></head>
<body>

    <main class="app">
        <header id="header" class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">Zhihong&#39;s Blog</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/zhbox">
                <span class="nav-text">中盒</span>
            </a>
        
            <a class="nav-item" href="/tags">
                <span class="nav-text">标签</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">关于</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="https://humble-zh.github.io"></form>

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HelloWorld"><span class="toc-number">1.</span> <span class="toc-text">HelloWorld</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">Java数据类型分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bprimitive-type"><span class="toc-number">2.1.</span> <span class="toc-text">基本数据类型primitive type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Breference-type-%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3%EF%BC%8C%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.</span> <span class="toc-text">引用数据类型reference type(类，接口，数组)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">进制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E6%B5%AE%E7%82%B9%E6%95%B0%E6%AF%94%E8%BE%83%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%94%A8%E7%B1%BB-BigDecimal"><span class="toc-number">3.1.</span> <span class="toc-text">避免使用浮点数比较，建议用类(BigDecimal)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">5.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">6.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">7.</span> <span class="toc-text">变量的命名规范</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85%E6%9C%BA%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">包机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaDoc"><span class="toc-number">10.</span> <span class="toc-text">JavaDoc</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Scanner%E5%AF%B9%E8%B1%A1"><span class="toc-number">11.</span> <span class="toc-text">Scanner对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Demo01-%E4%BD%BF%E7%94%A8next"><span class="toc-number">11.1.</span> <span class="toc-text">Demo01:使用next()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Demo02-%E4%BD%BF%E7%94%A8nextLine"><span class="toc-number">11.2.</span> <span class="toc-text">Demo02:使用nextLine()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91"><span class="toc-number">12.</span> <span class="toc-text">反编译</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">13.</span> <span class="toc-text">方法的重载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BC%A0%E5%8F%82"><span class="toc-number">14.</span> <span class="toc-text">命令行传参</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">15.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">16.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">17.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Arrays%E7%B1%BB"><span class="toc-number">18.</span> <span class="toc-text">Arrays类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">19.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84"><span class="toc-number">20.</span> <span class="toc-text">稀疏数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">21.</span> <span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#static%E6%96%B9%E6%B3%95"><span class="toc-number">22.</span> <span class="toc-text">static方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">23.</span> <span class="toc-text">值传递和引用传递</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">24.</span> <span class="toc-text">类和对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">25.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-number">26.</span> <span class="toc-text">创建对象内存分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">27.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">28.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%BE%8B%E7%A8%8B"><span class="toc-number">29.</span> <span class="toc-text">继承例程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#super"><span class="toc-number">30.</span> <span class="toc-text">super</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8super%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB"><span class="toc-number">30.1.</span> <span class="toc-text">用super调用父类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">30.2.</span> <span class="toc-text">super构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">30.3.</span> <span class="toc-text">方法重写</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">31.</span> <span class="toc-text">重载与重写区别：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">32.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#instanceof"><span class="toc-number">33.</span> <span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">34.</span> <span class="toc-text">类的转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#static"><span class="toc-number">35.</span> <span class="toc-text">static</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">35.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">35.2.</span> <span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#static%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">36.</span> <span class="toc-text">static代码块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%96%E9%83%A8package%E7%9A%84%E5%87%BD%E6%95%B0%E5%AF%BC%E5%85%A5"><span class="toc-number">37.</span> <span class="toc-text">外部package的函数导入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#final%E7%B1%BB"><span class="toc-number">38.</span> <span class="toc-text">final类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">39.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">40.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">41.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">41.1.</span> <span class="toc-text">成员内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">41.2.</span> <span class="toc-text">静态内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">41.3.</span> <span class="toc-text">局部内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">41.4.</span> <span class="toc-text">匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">42.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Error"><span class="toc-number">42.1.</span> <span class="toc-text">Error</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exception"><span class="toc-number">42.2.</span> <span class="toc-text">Exception</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">42.3.</span> <span class="toc-text">捕获异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">42.4.</span> <span class="toc-text">抛出异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">42.5.</span> <span class="toc-text">自定义异常</span></a></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
            <div id="wrapper" class="wrapper" style="max-width: 800px">
                <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            java学习1 Java零基础学习视频通俗易懂
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://humble-zh.github.io/2021/01/12/java%E5%AD%A6%E4%B9%A01_Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2021-01-12T06:05:42.000Z" itemprop="datePublished">2021-01-12</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/JAVA/" rel="tag">JAVA</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12J41137hu?from=search&seid=12777211954022913330">【狂神说Java】Java零基础学习视频通俗易懂</a></p>
<h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/humble/blog/<span class="built_in">source</span>/_posts/java on git:master x [18:27:56]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat Hello.java</span></span><br><span class="line">public class Hello&#123;</span><br><span class="line">    public static void main(String[] args)&#123; System.out.print(&quot;Hello World!&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/humble/blog/<span class="built_in">source</span>/_posts/java on git:master x [18:28:02]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> javac Hello.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/humble/blog/<span class="built_in">source</span>/_posts/java on git:master x [18:28:12]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">Hello.class  Hello.java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/humble/blog/<span class="built_in">source</span>/_posts/java on git:master x [18:28:13]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java Hello</span></span><br><span class="line">Hello World!%</span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/humble/blog/<span class="built_in">source</span>/_posts/java on git:master x [18:28:18]</span></span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>
<h1 id="Java数据类型分类"><a href="#Java数据类型分类" class="headerlink" title="Java数据类型分类"></a>Java数据类型分类</h1><h2 id="基本数据类型primitive-type"><a href="#基本数据类型primitive-type" class="headerlink" title="基本数据类型primitive type"></a>基本数据类型primitive type</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">byte num1 = 20;</span><br><span class="line">short num2 = 20;</span><br><span class="line">int num4 = 20;</span><br><span class="line">long num5 = 20L; //可以用L或l，但l容易跟1弄混</span><br><span class="line">float num6 = 50.1F;</span><br><span class="line">double num7 = 3.141592653;</span><br><span class="line">char num3 = &#x27;a&#x27;;</span><br><span class="line">boolean flag = true; //false</span><br></pre></td></tr></table></figure>
<h2 id="引用数据类型reference-type-类，接口，数组"><a href="#引用数据类型reference-type-类，接口，数组" class="headerlink" title="引用数据类型reference type(类，接口，数组)"></a>引用数据类型reference type(类，接口，数组)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = &quot;Lion&quot;;</span><br></pre></td></tr></table></figure>
<h1 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0b10010010 //二进制(0b)</span><br><span class="line">050 //八进制(0)</span><br><span class="line">0x1A //十六进制(0x)</span><br></pre></td></tr></table></figure>
<h2 id="避免使用浮点数比较，建议用类-BigDecimal"><a href="#避免使用浮点数比较，建议用类-BigDecimal" class="headerlink" title="避免使用浮点数比较，建议用类(BigDecimal)"></a>避免使用浮点数比较，建议用类(BigDecimal)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">float f = 0.1F;</span><br><span class="line">double d = 1.0/10;</span><br><span class="line">if(f == d)   //false</span><br><span class="line"></span><br><span class="line">float d1 = 123123123123123123F;</span><br><span class="line">float d2 = d1 + 1;</span><br><span class="line">if(d1 == d2) //true</span><br></pre></td></tr></table></figure>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//byte,short,char -&gt; int -&gt; long -&gt; float -&gt; double //低-&gt;高 (高-&gt;低:强制类型转换 低-&gt;高:自动类型转换)</span><br><span class="line">int i = 128;</span><br><span class="line">byte b = (byte)i; //-128 强制转换 内存溢出</span><br><span class="line">double d = i; //128 自动转换</span><br><span class="line">int j = (int)23.7; //23</span><br><span class="line">int k = (int)-45.89f; //-45</span><br><span class="line">int money = 10_0000_0000; //1000000000, JDK7新特性，可以用下划线分割数字</span><br><span class="line">long total = money * 12; //int型溢出，改为 long total = (long)money * 12L;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>不能对boolean进行转换</li>
<li>不能把对象类型转成不相干的类型(把猪转人-no,把男转女-yes)</li>
<li>把高容量转低容量时，强制转换</li>
<li>转换时可能存在内存溢出或精度问题</li>
</ul>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul>
<li>类变量：(static)初始默认值是null</li>
<li>实例变量：从属于对象，若不初始化，默认值是 0/0.0</li>
<li>局部变量：必须声明和初始化</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Variable&#123;</span><br><span class="line">    static int allClicks = 0; //类变量</span><br><span class="line">    String str=&quot;hello world&quot;; //实例变量</span><br><span class="line"></span><br><span class="line">    public void method()&#123;</span><br><span class="line">        int i=0; //局部变量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final double PI=3.14; //常量名建议使用全大写</span><br><span class="line"></span><br><span class="line">/* 修饰符关键字不分先后顺序 */</span><br><span class="line">static final double PI=3.14;</span><br><span class="line">final static double PI=3.14;</span><br></pre></td></tr></table></figure>
<h1 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h1><ul>
<li>类成员变量：首字母小写驼峰命名法</li>
<li>局部变量：首字母小写驼峰命名法</li>
<li>常量：大写字母和下划线</li>
<li>类名：首字母大写驼峰命名法</li>
<li>方法名：首字母小写驼峰命名法</li>
</ul>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ul>
<li>算数运算符<code>+,-,*,/,%,++,--</code></li>
<li>赋值运算符<code>=</code></li>
<li>关系运算符<code>&gt;,&lt;,&gt;=,&lt;=,==,!=,instanceof</code></li>
<li>逻辑运算符<code>&amp;&amp;,||,!</code></li>
<li>位运算符<code>&amp;,|,^,~,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;</code></li>
<li>条件运算符<code>? :</code></li>
<li>扩展赋值运算符<code>+=,-=,*=,/=</code></li>
</ul>
<p>IDEAtips:<code>Ctrl+d</code>是复制当前行到下一行</p>
<p>短路运算</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int c=5;</span><br><span class="line">boolean d = (c&lt;4)&amp;&amp;(c++&lt;4); //d是false,c是5</span><br></pre></td></tr></table></figure>
<p>字符串连接符号<code>+</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">int b=20;</span><br><span class="line">&quot;&quot;+a+b //&quot;1020&quot;</span><br><span class="line">a+b+&quot;&quot; //&quot;30&quot;</span><br></pre></td></tr></table></figure>
<h1 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h1><p>是为了更好地组织类，并且区别类名的命名空间。常用公司域名倒置作为包名:<code>com.baidu.www</code>。package用来封装包，import用来导入包（import需要放置在package后面）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package pkg1[. pkg2[. pkg3... ]];</span><br><span class="line">import package1[.package2...].(classname|*); //*是通配符，表示导入包下所有的类</span><br></pre></td></tr></table></figure>
<p>IDEAtips：需要用外部包的变量或方法时报错忘记import，按<code>Alt+Enter</code>可查询包方便导入</p>
<h1 id="JavaDoc"><a href="#JavaDoc" class="headerlink" title="JavaDoc"></a>JavaDoc</h1><p>javadoc命令是用来生成自己API文档的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">参数信息</span><br><span class="line">  <span class="meta">@author</span> 作者名</span><br><span class="line">  <span class="meta">@version</span> 版本号</span><br><span class="line">  <span class="meta">@since</span> 指明需要最早适用的jdk版本</span><br><span class="line">  <span class="meta">@param</span> 参数名</span><br><span class="line">  <span class="meta">@return</span> 返回值情况</span><br><span class="line">  <span class="meta">@throws</span> 异常抛出情况</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.humble.base;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author humble</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @since 1.8</span><br><span class="line"> */</span><br><span class="line">public class Hello &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public String test(String name) throws Exception&#123; return name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在idea里右键Hello的类，<code>Show in Files</code>，在当前目录打开命令行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src/com/humble/base [23:19:05]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">Hello.java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src/com/humble/base [23:19:07]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> javadoc -encoding UTF-8 -charset UTF-8 Hello.java</span></span><br><span class="line">正在加载源文件Hello.java...</span><br><span class="line">正在构造 Javadoc 信息...</span><br><span class="line">标准 Doclet 版本 1.8.0_265</span><br><span class="line">正在构建所有程序包和类的树...</span><br><span class="line">正在生成./com/humble/base/Hello.html...</span><br><span class="line">Hello.java:17: 警告 - @return 标记没有参数。</span><br><span class="line">正在生成./com/humble/base/package-frame.html...</span><br><span class="line">正在生成./com/humble/base/package-summary.html...</span><br><span class="line">正在生成./com/humble/base/package-tree.html...</span><br><span class="line">正在生成./constant-values.html...</span><br><span class="line">正在构建所有程序包和类的索引...</span><br><span class="line">正在生成./overview-tree.html...</span><br><span class="line">正在生成./index-all.html...</span><br><span class="line">正在生成./deprecated-list.html...</span><br><span class="line">正在构建所有类的索引...</span><br><span class="line">正在生成./allclasses-frame.html...</span><br><span class="line">正在生成./allclasses-noframe.html...</span><br><span class="line">正在生成./index.html...</span><br><span class="line">正在生成./help-doc.html...</span><br><span class="line">1 个警告</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src/com/humble/base [23:19:47]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">allclasses-frame.html    Hello.java          package-list</span><br><span class="line">allclasses-noframe.html  help-doc.html       script.js</span><br><span class="line">com                      index-all.html      stylesheet.css</span><br><span class="line">constant-values.html     index.html</span><br><span class="line">deprecated-list.html     overview-tree.html</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src/com/humble/base [23:21:36]</span></span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>
<p>用浏览器打开<code>index.html</code>即可</p>
<h1 id="Scanner对象"><a href="#Scanner对象" class="headerlink" title="Scanner对象"></a>Scanner对象</h1><p>用于获取用户输入</p>
<h2 id="Demo01-使用next"><a href="#Demo01-使用next" class="headerlink" title="Demo01:使用next()"></a><code>Demo01</code>:使用<code>next()</code></h2><ul>
<li>1.一定要读取到有效字符后才可以结束输入</li>
<li>2.对输入有效字符前遇到的空白，next()方法会自动将其去掉</li>
<li>3.只有输入有效字符后才将其后面输入的空白作为分隔符或结束符</li>
<li>4.next()不能得到带有空格的字符串</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.humble.scanner;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建扫描器对象，用于接收键盘数据</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;使用next方式接收：&quot;);</span><br><span class="line"></span><br><span class="line">        if(scanner.hasNext())&#123; //判断用户有没有输入字符串</span><br><span class="line">            //使用next方式接收</span><br><span class="line">            String str = scanner.next(); //程序会等待用户输入完毕</span><br><span class="line">            System.out.println(&quot;输入内容为：&quot; + str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //凡是属于IO流的类，如果不关闭会一直占用资源，要养成良好习惯，用完就关</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行Demo01(只输出了空格前的单词,再调用next()可获得下一个单词)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用next方式接收：</span><br><span class="line">hello world!</span><br><span class="line">输入内容为：hello</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<h2 id="Demo02-使用nextLine"><a href="#Demo02-使用nextLine" class="headerlink" title="Demo02:使用nextLine()"></a><code>Demo02</code>:使用<code>nextLine()</code></h2><ul>
<li>1.以Enter为结束符，即返回的是回车之前的全部字符</li>
<li>2.可以获得空白字符</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.humble.scanner;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Demo02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;使用nextline方式接收：&quot;);</span><br><span class="line">        if(scanner.hasNextLine())&#123;</span><br><span class="line">            //使用nextline方式接收</span><br><span class="line">            String str = scanner.nextLine(); //程序会等待用户输入完毕</span><br><span class="line">            System.out.println(&quot;输入内容为：&quot; + str);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行Demo02(输出整行)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用nextline方式接收：</span><br><span class="line">hello world!</span><br><span class="line">输入内容为：hello world!</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<h1 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h1><p><code>Project Structure</code>-<code>Project Settings</code>-<code>Project</code>-<code>Project comcompiler output</code><br>打开对应目录，子目录里面会有<code>.class</code>文件，把class文件拷贝到项目目录，然后导入到idea即可看到源码</p>
<p>IDEAtips:输入<code>100.for</code>即可补全for循环100次</p>
<h1 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h1><p>重载就是在一个类中，有相同的方法名称，但形参不同的方法。</p>
<p>重载规则：</p>
<ul>
<li>1.方法名称必须相同</li>
<li>2.参数列表必须不同（个数不同、类型不同、参数排列不同等）</li>
<li>3.方法的返回类型可以相同也可不同</li>
<li>4.仅仅返回类型不同不足以成为方法的重载</li>
</ul>
<p>实现理论：方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</p>
<h1 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.humble.base;</span><br><span class="line"></span><br><span class="line">public class Hello &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">            System.out.println(&quot;arg[&quot; + &quot;] is &quot; + args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src/com/humble/base [16:19:41]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">Hello.java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src/com/humble/base [16:19:41]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> javac Hello.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src/com/humble/base [16:19:47]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">Hello.class  Hello.java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src/com/humble/base [16:20:07]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ../../../</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src [16:20:12]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src [16:20:13]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java com.humble.base.Hello</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src [16:20:28]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java com.humble.base.Hello this is argv</span></span><br><span class="line">arg[] is this</span><br><span class="line">arg[] is is</span><br><span class="line">arg[] is argv</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src [16:20:38]</span></span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>
<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><ul>
<li>JDK1.5开始，java支持：给一个方法传递同类型的可变参数</li>
<li>在方法声明中，在指定参数类型后面加一个省略号(…)</li>
<li>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</li>
</ul>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归结构包括两个部分：</p>
<ul>
<li>递归头：什么时候不调用自身方法。如果没有头，将陷入死循环。</li>
<li>递归体：什么时候需要调用自身方法。</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar; //首选</span><br><span class="line">dataType arrayRefVar[]; //只是为了方便C/C++程序员</span><br><span class="line">dataType[] arrayRefVar = new dataType[arraySize];</span><br></pre></td></tr></table></figure>
<p>三种初始化</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//静态初始化</span><br><span class="line">int[] a = &#123;1,2,3&#125;;</span><br><span class="line">Man[] mans = &#123;new Man(1,1), new Man(2,2)&#125;;</span><br><span class="line"></span><br><span class="line">//动态初始化</span><br><span class="line">int[] a = new int[2];</span><br><span class="line">a[0] = 1;</span><br><span class="line">a[1] = 2;</span><br><span class="line"></span><br><span class="line">//数组默认初始化：数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中每个元素也被按照实例变量同样的方式被隐式初始化。</span><br></pre></td></tr></table></figure>
<h1 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h1><p>数组本身没有什么方法提供调用，但API中提供了工具类<code>java.util.Arrays</code>对数据对象进行一些基本操作。<code>Arrays</code>类中的方法都是<code>Static</code>修饰的静态方法，使用时可以直接用类名调用，不需要使用对象来调用（想用对象也可以）。</p>
<ul>
<li>给数组赋值用<code>fill</code>方法</li>
<li>对数组排序用<code>sort</code>方法，按升序</li>
<li>比较数组用<code>equals</code>，比较元素值是否相等</li>
<li>查找数组元素用<code>binarySearch</code>，对排好序的数组进行二分发查找</li>
</ul>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static int[] sort(int[] a)&#123;</span><br><span class="line">    int tmp = 0;</span><br><span class="line">    boolean flag = false; //假设已经排好序，即无需位置交换</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; a.length - 1; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; a.length - 1 - i; j++) &#123;</span><br><span class="line">            if(a[j+1] &lt; a[j])&#123;</span><br><span class="line">                tmp = a[j];</span><br><span class="line">                a[j] = a[j+1];</span><br><span class="line">                a[j+1] = tmp;</span><br><span class="line">                flag = true; //表示有位置交换</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /* 确实没有发生位置交换，表示已经排好序 */</span><br><span class="line">        if(!flag)&#123; break; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h1><p>当数组中大部分元素为0,或者为同一值时，可以使用稀疏数组来保存。处理方式是：</p>
<ul>
<li>记录数组一共几行几列几个非0值</li>
<li>把具有不同值的元素和行列及值记录在一个小规模数组中，从而压缩数据</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[][] array1 = new int[11][11];</span><br><span class="line">        array1[1][2] = 1;</span><br><span class="line">        array1[2][3] = 2;</span><br><span class="line">        for (int[] ints : array1) &#123; //打印原数组</span><br><span class="line">            for (int anInt : ints) &#123; System.out.print(anInt); &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;==开始转为稀疏数组==&quot;);</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int[] ints : array1) &#123; //统计非0总数</span><br><span class="line">            for (int anInt : ints) &#123;</span><br><span class="line">                if(anInt != 0) &#123; sum++; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //总长、总宽、非0总数</span><br><span class="line">        int[][] array2 = new int[sum+1][3];</span><br><span class="line">        array2[0][0] = array1[0].length;</span><br><span class="line">        array2[0][1] = array1.length;</span><br><span class="line">        array2[0][2] = sum;</span><br><span class="line"></span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; array1.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; array1[i].length; j++) &#123;</span><br><span class="line">                if(array1[i][j] != 0)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    array2[count][0] = i;</span><br><span class="line">                    array2[count][1] = j;</span><br><span class="line">                    array2[count][2] = array1[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;cow\trow\tvalue&quot;);</span><br><span class="line">        for (int[] ints : array2) &#123; System.out.println(Arrays.toString(ints)); &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;==开始还原数组==&quot;);</span><br><span class="line">        int[][] array3 = new int[array2[0][0]][array2[0][1]];</span><br><span class="line">        for (int i = 1; i &lt; array2.length; i++) &#123;</span><br><span class="line">            array3[array2[i][0]][array2[i][1]] = array2[i][2];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int[] ints : array1) &#123;</span><br><span class="line">            for (int anInt : ints) &#123; System.out.print(anInt); &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">00000000000</span><br><span class="line">00100000000</span><br><span class="line">00020000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">==开始转为稀疏数组==</span><br><span class="line">cow	row	value</span><br><span class="line">[11, 11, 2]</span><br><span class="line">[1, 2, 1]</span><br><span class="line">[2, 3, 2]</span><br><span class="line">==开始还原数组==</span><br><span class="line">00000000000</span><br><span class="line">00100000000</span><br><span class="line">00020000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br></pre></td></tr></table></figure>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><ul>
<li>对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是具体到微观操作，仍然需要面向过程的思路取处理。</li>
<li>面向对象编程（Object-Oriented Programming），本质是：以类的方式组织代码，以对象的方式组织/封装数据。</li>
<li>三大特性：封装、继承、多态。</li>
<li>从认识的角度考虑是先有对象后有类。对象是具体的事物；类是针对对象的抽象。</li>
<li>从代码运行角度考虑是先有类后有对象。类是对象的模板。</li>
</ul>
<h1 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h1><ul>
<li>带<code>static</code>：方法在类定义时就已经加载，所以其它地方可以直接用<code>类名</code>调用方法。</li>
<li>非<code>static</code>：方法在对象定义时才加载，所以其它地方必须先实例化才能用实例（<code>对象</code>）调用方法。</li>
<li>定义类时，在<code>static</code>方法内调用自己的<code>非static</code>方法会失败；在<code>非static</code>方法内可以直接调用自己的<code>非static</code>方法。</li>
</ul>
<h1 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h1><p>java里面调用方法都是<code>值传递</code>，不是<code>引用传递</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person();</span><br><span class="line">        System.out.println(person.name); //未定义所以打印 null</span><br><span class="line">        Hello.change(person); //传了对象（引用传递，址传递）</span><br><span class="line">        System.out.println(person.name); //打印出 world</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void change(Person person)&#123; person.name = &quot;world&quot;; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123; String name; &#125;</span><br></pre></td></tr></table></figure>
<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><ul>
<li>类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但不能代表某一个具体的事物。</li>
<li>对象是抽象概念的具体实例。</li>
<li>使用new关键字创建对象时，除了分配内存空间，还会给对象进行默认的初始化以及对类中构造器的调用。</li>
</ul>
<h1 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h1><ul>
<li>类中的构造器也称构造方法，是在进行创建对象的时候必须要调用的，目的在于初始化值。</li>
<li>没有人为初始化则默认为：<code>数字(0,0.0),char(u0000),boolean(false),引用(null)</code></li>
<li>构造器有两个特点：1.必须和类的名字相同，2.必须没有返回类型，也不能写void。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Application.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //Person humble = new Person(); //Person()实际上是构造方法</span><br><span class="line">        Person humble = new Person(&quot;Humble&quot;);</span><br><span class="line">        System.out.println(humble.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Person.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    //即使留空，默认也会存在一个无参构造方法Person()</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    String name;</span><br><span class="line">    //显式定义无参构造方法</span><br><span class="line">    public Person()&#123; this.name = &quot;hello&quot;; &#125;</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    /*</span><br><span class="line">    当底下定义了带参构造方法，那其它地方就无法使用无参构造方法来创建实例</span><br><span class="line">    如果想保留无参构造方法，只需显式定义一下无参构造方法即可</span><br><span class="line">     */</span><br><span class="line">    public Person()&#123; &#125;</span><br><span class="line"></span><br><span class="line">    //定义有参构造方法</span><br><span class="line">    public Person(String name)&#123; this.name = name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IDEAtips:<code>Alt+Insert</code>-<code>Constructor</code>-选择属性或不选属性-<code>OK</code>即可光标处快速生成构造方法</p>
<h1 id="创建对象内存分析"><a href="#创建对象内存分析" class="headerlink" title="创建对象内存分析"></a>创建对象内存分析</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内存</span><br><span class="line">├── 栈(stack)</span><br><span class="line">└── 堆(heap)</span><br><span class="line">    ├── new分配区</span><br><span class="line">    └── 方法区</span><br><span class="line">        └── 静态方法区</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //new会在堆的new分配区申请一片内存并返回地址</span><br><span class="line">        //person变量保存在栈，它的值是一个指向堆的地址</span><br><span class="line">        Person person = new Person();</span><br><span class="line">        System.out.println(person.name); //未定义所以打印 null</span><br><span class="line">        Hello.change(person); //传了对象（引用传递，址传递）</span><br><span class="line">        System.out.println(person.name); //打印出 world</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void change(Person person)&#123;</span><br><span class="line">        //person虽然是值传递，但传的却是地址值（引用值）</span><br><span class="line">        //地址指向的是堆内new分配区的对象空间</span><br><span class="line">        person.name = &quot;world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123; String name; &#125;</span><br></pre></td></tr></table></figure>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><ul>
<li>程序设计应该“高内聚，低耦合”。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合是仅暴露少量的方法给外部使用。</li>
<li>信息隐藏：禁止别人直接访问对象中的数据，而应该通过操作接口来访问。</li>
<li>属性私有：get()或set()</li>
</ul>
<p>封装的好处：</p>
<ol>
<li>提高程序的安全性，保护数据</li>
<li>隐藏代码实现细节</li>
<li>统一接口</li>
<li>增加系统可维护性</li>
</ol>
<p>IDEAtips:<code>Alt+Insert</code>-<code>Getter and Setter</code>-选择属性或不选属性-<code>OK</code>即可光标处快速生成<code>get()</code>和<code>set()</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123; return name; &#125;</span><br><span class="line">    public void setName(String name) &#123; this.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123; return age; &#125;</span><br><span class="line">    public void setAge(int age) &#123; //用set修改私有属性可以保护数据合法性</span><br><span class="line">        if(age &gt; 120 || age &lt; 0)&#123; this.age = 3; &#125;</span><br><span class="line">        else &#123; this.age = age; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123; return id; &#125;</span><br><span class="line">    public void setId(int id) &#123; this.id = id; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul>
<li>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。</li>
<li><code>extends</code>意思是扩展。子类是父类的扩展。</li>
<li>java中类只有单继承，没有多继承。</li>
<li>继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字extends来表示。子类和父类之间，从意义上讲应该具有”is a”的关系。</li>
<li>继承是类和类之间的一种关系。除此之外，类和类之间的关系还有<code>依赖、组合、聚合</code>等。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Student extends Person &#123; &#125; //Student继承Person</span><br><span class="line">public class Student &#123; //Student和person是组合关系</span><br><span class="line">    Person person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="继承例程"><a href="#继承例程" class="headerlink" title="继承例程"></a>继承例程</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Person.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    //public:可以被子类继承</span><br><span class="line">    //protected: 可被子继承</span><br><span class="line">    //default:(不加修饰就是这个)</span><br><span class="line">    //private:不可被子类继承(提供public get()/set())</span><br><span class="line"></span><br><span class="line">    protected int money = 10_0000_0000;</span><br><span class="line">    public void say() &#123; System.out.println(&quot;I am a Person&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package com.oop.demo;</span><br><span class="line">public class Student extends Person &#123; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Application.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student s1 = new Student();</span><br><span class="line">        System.out.println(s1.money); //1000000000</span><br><span class="line">        s1.say(); //I am a Person</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IDEAtips:<code>Ctrl+h</code>可以打开继承树</p>
<p>java中所有的类都默认直接或间接继承<code>Object类</code></p>
<h1 id="super"><a href="#super" class="headerlink" title="super"></a>super</h1><ul>
<li>super()调用父类的构造方法，必须在构造方法的第一行</li>
<li>super只能出现在’子类’的方法或构造方法中</li>
<li>super和this不能同时调用构造方法</li>
</ul>
<h2 id="用super调用父类"><a href="#用super调用父类" class="headerlink" title="用super调用父类"></a>用super调用父类</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Person.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Person &#123; //如果修饰改为private，那么子类就无法用super直接调用</span><br><span class="line">    protected String name = &quot;person1&quot;;</span><br><span class="line">    public void print()&#123; System.out.println(&quot;Person.print&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Student.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Student extends Person &#123;</span><br><span class="line">    private String name = &quot;student1&quot;;</span><br><span class="line"></span><br><span class="line">    public void test(String name)&#123;</span><br><span class="line">        System.out.println(name); //$&#123;name&#125;</span><br><span class="line">        System.out.println(this.name); //student1</span><br><span class="line">        System.out.println(super.name); //person1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print()&#123; System.out.println(&quot;Student.print&quot;); &#125;</span><br><span class="line">    public void test1()&#123;</span><br><span class="line">        print(); //Student.print</span><br><span class="line">        this.print();//Student.print</span><br><span class="line">        super.print();//Person.print</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Application.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student s1 = new Student();</span><br><span class="line">        s1.test(&quot;hello&quot;);</span><br><span class="line">        s1.test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*运行输出</span><br><span class="line">hello</span><br><span class="line">student1</span><br><span class="line">person1</span><br><span class="line">Student.print</span><br><span class="line">Student.print</span><br><span class="line">Person.print</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h2 id="super构造器"><a href="#super构造器" class="headerlink" title="super构造器"></a>super构造器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Person.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    public Person()&#123; System.out.println(&quot;Person.Person&quot;); &#125;</span><br><span class="line">    public Person(String name)&#123; System.out.println(&quot;Person.Person:&quot;+name); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Student.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Student extends Person &#123;</span><br><span class="line">    public Student() &#123;</span><br><span class="line">        //隐藏调用，默认会先调用父类构造器super()。</span><br><span class="line">        //如果想显式调用super()则必须放在子类构造器第一行。</span><br><span class="line">        //若父类构造器有参，那么调用super()要带参，除非父类构造器重载</span><br><span class="line">        //super();</span><br><span class="line">        super(&quot;hello&quot;);</span><br><span class="line">        System.out.println(&quot;Student.Student&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Application.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123; Student s1 = new Student(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*运行输出</span><br><span class="line">Person.Person:hello</span><br><span class="line">Student.Student</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>为什么需要方法重写？（父类的功能，子类不一定需要或不一定满足）</p>
<p>方法重写注意：</p>
<ul>
<li><ol>
<li>需要继承关系，子类重写父类的方法；</li>
</ol>
</li>
<li><ol start="2">
<li>只针对方法，不能是属性，并且是‘对象的方法（即非<code>static</code>修饰的）’，不是‘类的方法’，；</li>
</ol>
</li>
<li><ol start="3">
<li>方法名必须相同；</li>
</ol>
</li>
<li><ol start="4">
<li>返回值与参数列表及类型必须相同（否则就是重载了）；</li>
</ol>
</li>
<li><ol start="5">
<li>修饰符：范围可以扩大但不能缩小（即父用<code>public</code>修饰那么子重写时就不能用<code>protected</code>或更小的来修饰），<code>public</code>&gt;<code>protected</code>&gt;<code>default</code>&gt;<code>private</code>；正常情况不会是<code>private</code>，因为这个方法不能用对象去调用，所以只要不是<code>private</code>都可以被子重写。</li>
</ol>
</li>
<li><ol start="6">
<li>抛出的异常：范围可以被缩小但不能扩大；<code>ClassNotFoundException</code>(小)–&gt;<code>Exception</code>(大)</li>
</ol>
</li>
</ul>
<p>例子1：带<code>static</code>方法（类的方法）该例子不是方法重写</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: B.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class B &#123;</span><br><span class="line">    public static void test()&#123; System.out.println(&quot;B.test&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: A.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class A extends B &#123;</span><br><span class="line">    public static void test()&#123; System.out.println(&quot;A.test&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Application.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //类里面的static方法应该用类去调用，这里用对象去调用是为了测试</span><br><span class="line">        A a = new A();</span><br><span class="line">        a.test(); //最终调用类的方法</span><br><span class="line"></span><br><span class="line">        //父类的引用指向子类</span><br><span class="line">        B b = new A();</span><br><span class="line">        b.test(); //最终调用类的方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*运行输出如下，说明方法的调用只和定义的数据类型有关，跟new A()无关</span><br><span class="line">A.test</span><br><span class="line">B.test</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>例子2：不带<code>static</code>方法（对象的方法）该例子是方法重写</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: B.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class B &#123;</span><br><span class="line">    public /*static*/ void test()&#123; System.out.println(&quot;B.test&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: A.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class A extends B &#123;</span><br><span class="line">    @Override //@表示注解，是有功能的注释。Override表示重写</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        //super.test(); //默认是调用父类的方法，现在重写</span><br><span class="line">        System.out.println(&quot;A.test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Application.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A a = new A();</span><br><span class="line">        a.test(); //最终调用对象的方法</span><br><span class="line"></span><br><span class="line">        B b = new A();</span><br><span class="line">        b.test(); //最终调用对象的方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*运行输出如下，只要是new A()就是调用重写后的方法</span><br><span class="line">A.test</span><br><span class="line">A.test</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>IDEAtips:<code>Alt+Insert</code>选<code>Override Methods</code></p>
<p>类的方法优先级高于对象的方法。</p>
<ul>
<li>例子1里面，<code>static</code>修饰的是类方法。<code>b.test()</code>调用的是<code>B类</code>的<code>test()</code>，(堆里面静态方法区)</li>
<li>例子2里面，无<code>static</code>修饰是对象方法。<code>b.test()</code>调用的是<code>对象b</code>的<code>test()</code>，但<code>对象b</code>是<code>A类</code>new出来的，(堆里面new分配区)</li>
</ul>
<h1 id="重载与重写区别："><a href="#重载与重写区别：" class="headerlink" title="重载与重写区别："></a>重载与重写区别：</h1><ul>
<li>重载是同一类里，方法名相同，参数个数或类型不同。</li>
<li>重写是子父类间，子类重写父类的方法，方法名及参数一模一样，方法体不一样。并且不能是类方法，即不能用<code>static</code>修饰。</li>
</ul>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul>
<li>同一个方法根据调用对象的不同而采取不同的行为方式。</li>
<li>其中调用对象的类型需要在执行过程中才能决定。</li>
<li>一个对象的实际类型是确定的（堆的new分配区），但是指向它的引用（栈）可以是其他类型（父类或关系类）</li>
</ul>
<p>注意事项：</p>
<ul>
<li>1.多态是针对方法的，不能是属性。</li>
<li>2.必须有父子关系（继承），否则引用不能转换，比如<code>String s4 = new Student();</code> 转换异常ClassCastException</li>
<li>3.存在条件：必须父子关系（继承）；方法需要重写（只有运行时才知道调用父方法还是子重写的方法）；父类引用指向子类；</li>
</ul>
<p>不能被子重写的方法：</p>
<ul>
<li>1.<code>static</code>方法，属于类，不属于实例</li>
<li>2.<code>final</code>常量，</li>
<li>3.<code>private</code>方法（因为不能继承）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Person.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Person &#123; public void run()&#123; System.out.println(&quot;Person.run&quot;); &#125; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Student.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Student extends Person &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123; System.out.println(&quot;Student.run&quot;); &#125;</span><br><span class="line"></span><br><span class="line">    public void eat()&#123; System.out.println(&quot;Student.eat&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Application.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student s1 = new Student();</span><br><span class="line">        Person s2 = new Student();</span><br><span class="line">        Object s3 = new Student();</span><br><span class="line">        //String s4 = new Student(); //报错，引用只能是同类或父类</span><br><span class="line"></span><br><span class="line">        //如果Student没有Override run方法，那两个都是Person.run</span><br><span class="line">        //如果Student有Override run方法，那两个都是Student.run</span><br><span class="line">        s1.run();</span><br><span class="line">        s2.run();</span><br><span class="line">        //s3.run(); //报错，Object没有run方法</span><br><span class="line"></span><br><span class="line">        s1.eat();</span><br><span class="line">        //s2.eat(); //报错，因为父(Person)没有子(Student)的方法(eat)所以不能调，可以先强转为Student再调用</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 所以，左边定义的类里有什么方法就只能调这些方法（自己的或继承的）</span><br><span class="line">         * 如果这些方法已被子类重写那调用就是重写后的方法</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p><code>X instanceof Y</code>，Y 必须是 引用X所指向的实例 的父类/同类才为真</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Person.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line">public class Person &#123; public void run()&#123; System.out.println(&quot;Person.run&quot;); &#125; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Student.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line">public class Student extends Person &#123; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Teacher.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line">public class Teacher extends Person &#123; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Application.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object o = new Student();</span><br><span class="line">        System.out.println(o instanceof Student); //true</span><br><span class="line">        System.out.println(o instanceof Person); //true</span><br><span class="line">        System.out.println(o instanceof Object); //true</span><br><span class="line">        System.out.println(o instanceof Teacher); //false</span><br><span class="line">        System.out.println(o instanceof String); //false</span><br><span class="line">        System.out.println(&quot;=====&quot;);</span><br><span class="line">        Person p = new Student();</span><br><span class="line">        System.out.println(p instanceof Student); //true(说Person是Student不成立，但引用p指向的实例是Student)</span><br><span class="line">        System.out.println(p instanceof Person); //true</span><br><span class="line">        System.out.println(p instanceof Object); //true</span><br><span class="line">        System.out.println(p instanceof Teacher); //false</span><br><span class="line">        //System.out.println(p instanceof String); //编译报错</span><br><span class="line">        System.out.println(&quot;=====&quot;);</span><br><span class="line">        Student s = new Student();</span><br><span class="line">        System.out.println(s instanceof Student); //true</span><br><span class="line">        System.out.println(s instanceof Person); //true</span><br><span class="line">        System.out.println(s instanceof Object); //true</span><br><span class="line">        //System.out.println(s instanceof Teacher); //编译报错</span><br><span class="line">        //System.out.println(s instanceof String); //编译报错</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类的转换"><a href="#类的转换" class="headerlink" title="类的转换"></a>类的转换</h1><ul>
<li>1.类的转换是发生在栈上，也就是转换引用而已</li>
<li>2.把子类‘直接’转为父类，父类的引用(栈)指向子类的对象(堆)，但是会丢失子类的方法</li>
<li>3.把父类‘强制’转为子类，子类的引用(栈)指向父类的对象(堆)，编译报错或运行报错，因为子类引用(栈)里有些方法在父类对象(堆)内找不到</li>
<li>4.类的转换方便方法的调用，减少重复的代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Person.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line">public class Person &#123; public void run()&#123; System.out.println(&quot;Person.run&quot;); &#125; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Student.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line">public class Student extends Person &#123; public void go()&#123; System.out.println(&quot;Student.go&quot;); &#125; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Application.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p = new Person();</span><br><span class="line">        //Student conversion2s1 = p; //编译报错，因为堆内的对象为Person(父)，不能用栈内Student(子)引用去指向它，需要强转</span><br><span class="line">        //Student conversion2s2 = (Student) p; //编译通过但运行报错，原因同上</span><br><span class="line"></span><br><span class="line">        Student s = new Student();</span><br><span class="line">        Person conversion2p = s; //子类转父类</span><br><span class="line">        //conversion2p.go(); //编译报错，因为栈内引用Person没有go方法，也就是丢失了Student(子)的方法go</span><br><span class="line">        Student reset2s = (Student)conversion2p;</span><br><span class="line">        reset2s.go(); //打印Student.go，证明转为父类会丢失子类方法go，再转回子类又恢复了方法go</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Student.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line">    private static int age;</span><br><span class="line">    private double score;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student s1 = new Student();</span><br><span class="line"></span><br><span class="line">        Student.age = 10; //类成员</span><br><span class="line">        s1.age = 20; //此处访问的也是类成员</span><br><span class="line">        System.out.println(s1.age); //20</span><br><span class="line">        System.out.println(Student.age); //20</span><br><span class="line"></span><br><span class="line">        //Student.score = 10; //编译报错，类被加载时不会分配非staitc的属性，非static属性是属于对象的</span><br><span class="line">        s1.score = 20;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Student.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line">public class Student &#123;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        go(); //对象方法内可以调用类的方法</span><br><span class="line">    &#125;</span><br><span class="line">    public static void go()&#123;</span><br><span class="line">        //run(); //编译报错:类的方法内不可以调用对象的方法</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //run(); //编译报错:类的方法内不可以调用对象的方法</span><br><span class="line">        go(); //类可以直接调用类自己的方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="static代码块"><a href="#static代码块" class="headerlink" title="static代码块"></a>static代码块</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Person.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    &#123; //2 :可以在里面赋初值</span><br><span class="line">        System.out.println(&quot;匿名代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static&#123; //1 静态代码块只执行/初始化一次</span><br><span class="line">        System.out.println(&quot;静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person() &#123; //3</span><br><span class="line">        System.out.println(&quot;构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p1 = new Person();</span><br><span class="line">        System.out.println(&quot;====&quot;);</span><br><span class="line">        Person p2 = new Person();</span><br><span class="line">        /**运行输出</span><br><span class="line">         * 静态代码块</span><br><span class="line">         * 匿名代码块</span><br><span class="line">         * 构造方法</span><br><span class="line">         * ====</span><br><span class="line">         * 匿名代码块</span><br><span class="line">         * 构造方法</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="外部package的函数导入"><a href="#外部package的函数导入" class="headerlink" title="外部package的函数导入"></a>外部package的函数导入</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Test.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line">import static java.lang.Math.random;</span><br><span class="line">import static java.lang.Math.PI;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Math.random()); //用package去调用random</span><br><span class="line">        System.out.println(random()); //也可以先import static java.lang.Math.random之后就可以直接调用</span><br><span class="line">        System.out.println(PI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h1><p>用<code>final</code>修饰的类是没有子类的。</p>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><ul>
<li><code>abstract</code>修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么就是抽象方法；修饰类那就是抽象类</li>
<li>抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。</li>
<li>抽象类不能用<code>new</code>关键字来创建对象，它是用来让子类继承的。</li>
<li>抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的。</li>
<li>子类继承抽象类，那么就必须要实现抽象类里没有实现的抽象方法，否则该子类也要声明为抽象类。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Action.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">//抽象(abstract)类，不能被new出来，只能被继承</span><br><span class="line">public abstract class Action &#123;</span><br><span class="line">    //抽象(abstract)方法如果：</span><br><span class="line">    // 被&quot;abstract修饰的子类&quot;继承可以不写方法体；</span><br><span class="line">    // 被&quot;非abstract修饰的子类&quot;继承需要写方法体。</span><br><span class="line">    public abstract void doSomething(); //抽象方法目的在于约束子类必须实现</span><br><span class="line">    public void go()&#123; System.out.println(&quot;Action.go&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:A.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line">public abstract class A extends Action &#123;</span><br><span class="line">    //因为doSomething()是抽象方法，所以子类(A)必须重写/实现出来，如果子类(A)是抽象类则不用重写/实现</span><br><span class="line">    //@Override</span><br><span class="line">    //public void doSomething() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    //Action.go()不是抽象方法，所以子类(A)可以重写/实现，也可以不重写/实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>javaTips:类是单继承，接口可以多继承</p>
<p>思考题：1.抽象类不能<code>new</code>,那它有构造器吗？2.抽象类存在意义是什么？（游戏角色抽象出来，让子类继承去实现。提高开发效率，可扩展性高）</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul>
<li><p>普通类：只有具体实现</p>
</li>
<li><p>抽象类：具体实现和规范（抽象方法）都有</p>
</li>
<li><p>接口：只有规范（使得约束和实现分离，项目组长约定好接口，员工面向接口编程）</p>
</li>
<li><p>接口就是规范，定义是一组规则，体现了现实世界中“如果你是…则必须能…”的意思。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。</p>
</li>
<li><p>接口本质是契约，就像我们人间的法律一样。制定好后大家都遵守。</p>
</li>
<li><p>OO的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言（如C+++,java,C#等），就是因为设计模式所研究的，实际上就是如何合理去抽象。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:UserService.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line">public interface UserService &#123;</span><br><span class="line">    //接口内的方法默认是public abstract，可省略不写</span><br><span class="line">    ///*public abstract*/ void run(String name);</span><br><span class="line">    void add(String name);</span><br><span class="line">    void delete(String name);</span><br><span class="line">    void update(String name);</span><br><span class="line">    void query(String name);</span><br><span class="line"></span><br><span class="line">    //接口内的属性默认是常量 public static final（一般不这样定义使用）</span><br><span class="line">    /*public static final*/ int AGE=99;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:TimeService.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line">public interface TimeService &#123; void timer(); &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:UserServiceImp.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">//接口都需要有实现类，它不能直接被实例化，因为没构造方法</span><br><span class="line">//如果类 implements 了接口，则必须重写里面所有的方法</span><br><span class="line">//类是多继承(extends)的，接口是多实现(implements)的，或者说，类可以集成实现多个接口(interface)</span><br><span class="line">public class UserServiceImp implements UserService,TimeService&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void add(String name) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void delete(String name) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(String name) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void query(String name) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void timer() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>内部类就是在一个类内部再定义一个类。比如A类中定义一个B类，那么B类相对A类来说就称为内部类，而A类相对B类来说就是外部类了。</p>
<ul>
<li>1.成员内部类</li>
<li>2.静态内部类</li>
<li>3.局部内部类</li>
<li>4.匿名内部类</li>
</ul>
<h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Outer.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line">public class Outer &#123;</span><br><span class="line">    private int id = 10;</span><br><span class="line">    public void out()&#123; System.out.println(&quot;这是外部方法&quot;); &#125;</span><br><span class="line"></span><br><span class="line">    public class Inner &#123; //成员内部类</span><br><span class="line">        public void in()&#123; System.out.println(&quot;这是内部方法&quot;); &#125;</span><br><span class="line"></span><br><span class="line">        //直接访问外部类的私有属性</span><br><span class="line">        public void getID()&#123; System.out.println(&quot;id = &quot; + id); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Application.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer outer = new Outer();</span><br><span class="line">        //通过外部类的&#x27;实例&#x27;去new 内部类</span><br><span class="line">        Outer.Inner inner = outer.new Inner();</span><br><span class="line">        inner.in(); //这是内部方法</span><br><span class="line">        inner.getID(); //id = 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Outer.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line">public class Outer &#123;</span><br><span class="line">    private int id = 10;</span><br><span class="line">    public void out()&#123; System.out.println(&quot;这是外部方法&quot;); &#125;</span><br><span class="line"></span><br><span class="line">    public static class Inner &#123; //静态内部类</span><br><span class="line">        public void in()&#123; System.out.println(&quot;这是内部方法&quot;); &#125;</span><br><span class="line"></span><br><span class="line">        //编译报错：Inner在静态区，id属性不在静态区，除非用static修饰id，否则必须实例化才能访问id</span><br><span class="line">        //public void getID()&#123; System.out.println(&quot;id = &quot; + id); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Application.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer outer = new Outer();</span><br><span class="line">        //直接new 外部类里的内部类</span><br><span class="line">        Outer.Inner inner = new Outer.Inner();</span><br><span class="line">        inner.in(); //这是内部方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:outer.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">public class Outer &#123; &#125;</span><br><span class="line"></span><br><span class="line">//一个java文件中可以有多个class，但只有一个public class</span><br><span class="line">class A&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;A.main&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:outer.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">public class Outer &#123;</span><br><span class="line">    public void method()&#123;</span><br><span class="line">        //局部内部类</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            public void in()&#123;</span><br><span class="line">                System.out.println(&quot;Inner.in&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Test.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //不需要变量保存实例，没有名字初始化类（匿名）</span><br><span class="line">        new Apple().eat(); //Apple.eat</span><br><span class="line"></span><br><span class="line">        //也是匿名类</span><br><span class="line">        UserService userService = new UserService() &#123;</span><br><span class="line">            @Override //运行的时候才重写/实现接口的方法，也就等于定义了新的类，并且用new实例化了，保存在userService中</span><br><span class="line">            public void hello() &#123;</span><br><span class="line">                System.out.println(&quot;Test.hello&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        userService.hello();//Test.hello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Apple &#123;</span><br><span class="line">    public void eat()&#123; System.out.println(&quot;Apple.eat&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface UserService&#123;</span><br><span class="line">    void hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ul>
<li>运行过程中出现状况：用户输入不合法；打开一个文件可是文件不存在或格式不合法；读数据库却是空的；内存耗光或硬盘满了……</li>
<li>软件程序在运行过程中，非常可能遇到刚刚提到的这些问题，叫做异常(<code>Exception</code>)，翻译是例外，可以理解为例外的情况就是异常情况。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Application.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(11/0); //Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3种类型的异常：</p>
<ul>
<li>1.检查性异常，最具代表的检查性异常是用户错误输入引起的异常，这是开发者无法预见的。如：打开一个不存在的文件就会引发异常。这个异常在编译时不能被简单地忽略。</li>
<li>2.运行时异常，最容易被避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>
<li>3.错误，错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如：当栈溢出的错误没办法在编译时就检查到。</li>
</ul>
<p>Java把异常当作对象处理，并定义一个基类<code>java.lang.Throwable</code>作为所有异常的超类。在Java API中已经定义了许多异常类，这些异常类分为两大类，错误<code>Error</code>和异常<code>Exception</code></p>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><ul>
<li><code>Error</code>类对象由Java虚拟机生成并抛出，大多数错误跟代码编写者所写的无关。</li>
<li>Java虚拟机运行错误(Virtual MachineError)，当JVM不再有继续执行操作所需的内存资源时，将出现<code>OutOfMemoryError</code>。这些异常发生时，Java虚拟机(JVM)一般会选择线程终止。</li>
<li>还有发生在虚拟机试图执行应用时，如类定义错误(<code>NoClassDefFoundError</code>)、链接错误(<code>LinkageError</code>)。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且大多数是程序运行时不允许出现这样的情况。</li>
</ul>
<h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p>在<code>Exception</code>分支中有一个重要的自类<code>RuntimeException</code>（运行时异常）</p>
<ul>
<li><code>ArrayIndexOutOfBoundsException</code>(数组下标越界)</li>
<li><code>NullPointerException</code>(空指针异常)</li>
<li><code>ArithmeticException</code>(算术异常)</li>
<li><code>MissingResourceException</code>(丢失资源)</li>
<li><code>ClassNotFoundException</code>(找不到类)</li>
<li>…<br>这些是不检查异常，程序中可以选择捕获处理，也可不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</li>
</ul>
<p><code>Error</code>和<code>Exception</code>的区别：</p>
<ul>
<li><code>Error</code>通常是灾难性、致命性的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机(JVM)一般会选择终止线程。</li>
<li><code>Exception</code>通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常</li>
</ul>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Test.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 1;</span><br><span class="line">        int b = 0;</span><br><span class="line"></span><br><span class="line">        //try catch 需要有，finally可以没有。finally一般是需要在异常后关闭IO、释放资源的情况写</span><br><span class="line">        try&#123; //try监控区域</span><br><span class="line">            System.out.println(a / b);</span><br><span class="line">        &#125;catch (ArithmeticException e)&#123; //catch 捕获到异常后的处理区</span><br><span class="line">            System.out.println(&quot;捕获异常，除数不能为0&quot;);</span><br><span class="line">        &#125;finally &#123; //处理善后区，不管有无捕获异常都会处理，</span><br><span class="line">            System.out.println(&quot;finally&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>捕获多个异常需要从小到大</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Test.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 1;</span><br><span class="line">        int b = 0;</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.println(a / b);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Error e)&#123;</span><br><span class="line">            System.out.println(&quot;Error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)&#123;</span><br><span class="line">            System.out.println(&quot;Exception&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable e)&#123;</span><br><span class="line">            System.out.println(&quot;Throwable&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            System.out.println(&quot;finally&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IDEAtips:选中代码，按<code>Ctrl+Alt+t</code>可弹出补全逻辑</p>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Test2.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">public class Test2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            new Test2().test(1,0);</span><br><span class="line">        &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //注意 throw 和 throws 两关键字</span><br><span class="line">    public void test(int a, int b) throws ArithmeticException&#123;</span><br><span class="line">        if (b == 0) &#123;</span><br><span class="line">            throw new ArithmeticException(); //throw 一般是在方法内处理不了，于是主动往更高级抛出异常</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(a / b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常（只需继承<code>Exception</code>类即可）</p>
<p>自定义异常类步骤：</p>
<ul>
<li>1.创建自定义异常类</li>
<li>2.在方法中通过<code>throw</code>关键字抛出异常对象</li>
<li>3.如果在当前抛出异常的方法中处理异常，则可使用<code>try-catch</code>语句捕获并处理；否则在方法的声明处通过<code>throws</code>关键字指明要抛出给方法调用者的异常，继续进行下一步操作</li>
<li>4.在出现异常方法的调用者中捕获并处理异常</li>
</ul>
<p>IDEAtips:双击<code>Shift</code>可弹出搜索框</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:MyException.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">//自定义异常类</span><br><span class="line">public class MyException extends Exception&#123;</span><br><span class="line">    //传递数字&gt;10</span><br><span class="line">    private int detail;</span><br><span class="line"></span><br><span class="line">    public MyException(int detail) &#123;</span><br><span class="line">        this.detail = detail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //toString:异常打印信息</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyException&#123;&quot; + &quot;detail=&quot; + detail + &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Test.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    static void test(int a) throws MyException &#123;</span><br><span class="line">        System.out.println(&quot;a = &quot; + a);</span><br><span class="line">        if (a &gt; 10)&#123;</span><br><span class="line">            throw new MyException(a);//抛出</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Test.test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            test(11);</span><br><span class="line">        &#125; catch (MyException e) &#123;</span><br><span class="line">            System.out.println(&quot;e = &quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 运行输出</span><br><span class="line"> * a = 11</span><br><span class="line"> * e = MyException&#123;detail=11&#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<ul>
<li>处理运行时异常时，采用逻辑去合理规避同时辅助<code>try-catch</code>处理</li>
<li>在多重catch块后面，可以加一个<code>catch(Exception)</code>来处理可能会被遗漏的异常</li>
<li>对于不确定的代码，可以加上<code>try-catch</code>，处理潜在的异常</li>
<li>尽量去处理异常，切忌只是简单地调用<code>printStackTrace()</code>去打印输出</li>
<li>具体如何处理异常，要根据不同的业务需求和异常类型去决定</li>
<li>尽量添加<code>finally</code>语句块去释放占用的资源</li>
</ul>

        
    </section>
</article>



<a id="pagenext" href="/2020/12/09/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/" class="article-next" title="C语言语法笔记"><i class="icon-arrow-right"></i></a>


<a id="pageprev" href="/2021/01/13/java%E5%AD%A6%E4%B9%A02_2020%E6%96%B0%E7%89%88_Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E6%9C%80%E6%96%B0%E6%95%99%E7%A8%8B_%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/" class="article-prev" title="java学习2 Java常用类最新教程 通俗易懂"><i class="icon-arrow-left"></i></a>



<div class="comments">
    <div id="comments"></div>
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
    new Gitalk({
        clientID: "7fbe80427f54741e289f",
        clientSecret: "f34ed5fd92e54c9000bd37ba951948cb939deff5",
        repo: "sanonz.github.io",
        owner: "sanonz",
        admin: ["sanonz"],
        id: "b6ba977d4801327ae83ec7b5d01e2f4f",
        distractionFreeMode: true,
        title: "java学习1 Java零基础学习视频通俗易懂",
        body: "https://humble-zh.github.io/2021/01/12/java%E5%AD%A6%E4%B9%A01_Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/",
        labels: ["JAVA"]
    }).render('comments');
    </script>
</div>



            </div>
        </div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?e4027971a230b210f4671f485b33846a";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
    
</footer>

    </main>

    <script type="text/javascript" src="https://unpkg.com/jquery@1.9.1/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }

            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle('normal', slideDone);
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp('normal', slideDone);
            }, 3000);
        }

        function slideDone() {
            if (nodes.navInner.css('display') !== 'none') {
                nodes.navInner.css('display', '');
            }
        }

        $(window).on('resize', function() {
            if ($(this).width() > 960) {
                nodes.navInner.css('display', '');
            }
        });
    });
    </script>
    
        
<script src="/js/scrollspy.min.js"></script>

        <script type="text/javascript">
        $(document.body).scrollspy({target: '#aside-inner'});

        $(window).on('resize', function() {
            var hw = $('#header').width();
            var ww = $('#wrapper').width();
            var space = ($(this).width() - hw - ww) / 2 / 2;

            var pageprev = $('#pageprev');
            var pagenext = $('#pagenext');
            var avg = (pageprev.width() + pagenext.width()) / 2

            if(space > avg) {
                var len = space - avg / 2;
                var styles = {position: 'fixed', top: '50%', marginTop: - (pageprev.width() + pagenext.width()) / 4}
                pageprev.css($.extend({left: hw + len}, styles));
                pagenext.css($.extend({right: len}, styles));
            } else {
                pageprev.removeAttr('style');
                pagenext.removeAttr('style');
            }
        }).trigger('resize');
        </script>
    

</body>
</html>
