<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>Zhihong&#39;s Blog</title>
    <meta name="author" content="Zhihong Li" />
    <meta name="keywords" content="zhbox" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />

    
    <link rel="alternate" href="/atom.xml" title="Zhihong&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <style type="text/css">
    @font-face {
        font-family: 'icomoon';
        src: url("/fonts/icomoon.eot?q628ml");
        src: url("/fonts/icomoon.eot?q628ml#iefix") format('embedded-opentype'),
             url("/fonts/icomoon.ttf?q628ml") format('truetype'),
             url("/fonts/icomoon.woff?q628ml") format('woff'),
             url("/fonts/icomoon.svg?q628ml#icomoon") format('svg');
        font-weight: normal;
        font-style: normal;
    }
    </style>
    
<link rel="stylesheet" href="/css/style.css">


    <!--[if lt IE 9]><style type="text/css">.nav-inner {top:0;}.author-meta {position:static;top:0;}.search-form {height:36px;}</style><script type="text/javascript" src="https://unpkg.com/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
<meta name="generator" content="Hexo 5.3.0"></head>
<body>

    <main class="app">
        <header id="header" class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">Zhihong&#39;s Blog</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item active" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/zhbox">
                <span class="nav-text">中盒</span>
            </a>
        
            <a class="nav-item" href="/tags">
                <span class="nav-text">标签</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">关于</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="https://humble-zh.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="Zhihong Li">
                </a>
            </div>
            
            <div class="author-name">Zhihong Li</div>
            <div class="author-work">Program Monkey</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">GuangZhou, China</span>
            </div>
            
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    
                        <a class="thread-item" href="https://github.com/humble-zh/zhbox" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewBox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M512 32.12c-265.004 0-479.88 220.23-479.88 492.090 0 217.446 137.536 401.684 328.202 466.81 23.994 4.498 32.778-10.712 32.778-23.78 0-11.782-0.428-42.632-0.642-83.764-133.466 29.778-161.744-65.984-161.744-65.984-21.852-56.772-53.344-71.982-53.344-71.982-43.49-30.636 3.214-29.992 3.214-29.992 48.202 3.428 73.482 50.772 73.482 50.772 42.846 75.196 112.258 53.558 139.68 40.918 4.284-31.706 16.71-53.558 30.42-65.77-106.474-12.426-218.516-54.63-218.516-243.152 0-53.772 18.638-97.69 49.274-131.966-4.928-12.426-21.424-62.556 4.714-130.252 0 0 40.276-13.282 131.966 50.344 38.348-10.926 79.266-16.282 120.184-16.496 40.704 0.214 81.836 5.57 120.184 16.496 91.692-63.626 131.752-50.344 131.752-50.344 26.136 67.698 9.64 117.828 4.714 130.252 30.636 34.492 49.274 78.408 49.274 131.966 0 188.952-112.258 230.514-219.16 242.724 17.138 15.21 32.564 45.202 32.564 91.048 0 65.77-0.642 118.898-0.642 134.966 0 13.068 8.57 28.492 32.992 23.566 191.094-64.912 328.418-249.152 328.418-466.382 0-271.86-214.874-492.090-479.88-492.090z"></path>
</svg>

                        </a>
                    
                </div>
            </div>
            
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
            <div id="wrapper" class="wrapper" style="max-width: 800px">
                
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2021/01/13/java%E5%AD%A6%E4%B9%A02_2020%E6%96%B0%E7%89%88_Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E6%9C%80%E6%96%B0%E6%95%99%E7%A8%8B_%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/">java学习2 Java常用类最新教程 通俗易懂</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://humble-zh.github.io/page/5/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2021-01-13T01:34:30.000Z" itemprop="datePublished">2021-01-13</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/JAVA/" rel="tag">JAVA</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1vt4y197nY?from=search&seid=17522514133022135498">千锋教育-2020新版 Java常用类最新教程 通俗易懂</a></p>
<h1 id="Java常用类最新教程-通俗易懂"><a href="#Java常用类最新教程-通俗易懂" class="headerlink" title="Java常用类最新教程 通俗易懂"></a>Java常用类最新教程 通俗易懂</h1><ul>
<li>1.内部类</li>
<li>2.包装类</li>
<li>3.Object类</li>
<li>4.String类</li>
<li>5.BigDecimal类</li>
<li>6.system类</li>
</ul>
<h2 id="1-内部类"><a href="#1-内部类" class="headerlink" title="1.内部类"></a>1.内部类</h2><p>成员内部类、静态内部类(static)、局部内部类(在方法内)、匿名内部类(常用在接口或抽象类)</p>
<p>概念：在一个类的内部再定义一个完整的类</p>
<p>特点：</p>
<ul>
<li>编译之后可生成独立的字节码文件</li>
<li>内部类可直接访问外部类私有成员，而不破坏封装</li>
<li>可为外部类提供必要的内部功能组件</li>
</ul>
<p><code>Outer$Inner.class</code></p>
<p><code>Outer.class</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 身体</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Body</span></span>&#123; <span class="comment">//生成1个class文件</span></span><br><span class="line">    <span class="comment">// 头部</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Header</span></span>&#123; <span class="comment">// 会生成另一个class文件,文件名用$分隔外和内 类名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-成员内部类"><a href="#1-1-成员内部类" class="headerlink" title="1.1.成员内部类"></a>1.1.成员内部类</h3><ul>
<li>在类的内部定义，与实例变量、实例方法同级别的类</li>
<li>外部类的一个实例部分，创建内部类对象时，必须依赖外部类对象(先创建外部类对象才能创建内部类对象)</li>
<li>当外部类、内部类存在重名属性时，会优先访问内部类属性</li>
<li>成员内部类里不能定义<strong>静态成员</strong>、可以包含<strong>静态常量(final)</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Outer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;<span class="comment">// 外部类</span></span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;<span class="comment">//内部类</span></span><br><span class="line">        <span class="keyword">private</span> String address = <span class="string">&quot;北京&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> String phone = <span class="string">&quot;110&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> String name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">        <span class="comment">//private static String country = &quot;中国&quot;; //编译报错,不能定义静态成员</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String country = <span class="string">&quot;中国&quot;</span>; <span class="comment">//编译通过,可以包含静态常量</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//打印外部类属性 此时有重名属性name</span></span><br><span class="line">            <span class="comment">//访问外部类属性用 Outer.this.name</span></span><br><span class="line">            sout(Outer.<span class="keyword">this</span>.name); <span class="comment">// 张三</span></span><br><span class="line">            sout(age); <span class="comment">//建议外部类属性全部加Outer.this.</span></span><br><span class="line">            <span class="comment">//打印内部类中的属性</span></span><br><span class="line">            sout(name); <span class="comment">// 李四</span></span><br><span class="line">            sout(<span class="keyword">this</span>.address); <span class="comment">//建议给所有属性加this</span></span><br><span class="line">            sout(<span class="keyword">this</span>.phone);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    psvm(String[] args)&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();<span class="comment">// 创建外部类对象</span></span><br><span class="line">        Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;<span class="comment">// 创建内部类对象</span></span><br><span class="line">        <span class="comment">//Inner inner = new Outer().new Inner();//也可把上面2行改成这样</span></span><br><span class="line">        inner.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-静态内部类"><a href="#1-2-静态内部类" class="headerlink" title="1.2.静态内部类"></a>1.2.静态内部类</h3><ul>
<li>不依赖外部类对象，可直接创建或通过类名访问，可声明静态成员</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Outer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;<span class="comment">// 外部类,不能用static修饰</span></span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;<span class="comment">// 静态内部类，和外部类相同级别</span></span><br><span class="line">        <span class="keyword">private</span> String address = <span class="string">&quot;上海&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> String phone = <span class="string">&quot;111&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1000</span>;<span class="comment">// 静态成员</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">// 访问外部类的属性</span></span><br><span class="line">            <span class="comment">//sout(name); //编译报错,不能直接访问,当作外部类同级的类去访问</span></span><br><span class="line">            Outer outer = <span class="keyword">new</span> Outer();<span class="comment">// 1. 先创建外部类对象</span></span><br><span class="line">            sout(outer.name);<span class="comment">//xxx 2. 调用外部类对象的属性</span></span><br><span class="line">            sout(outer.age);<span class="comment">//20</span></span><br><span class="line">            <span class="comment">// 调用静态内部类的属性和方法</span></span><br><span class="line">            sout(address);<span class="comment">//上海</span></span><br><span class="line">            sout(phone);<span class="comment">//111</span></span><br><span class="line">            sout(Inner.count);<span class="comment">//1000 调用静态内部类的静态属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    psvm(String[] args)&#123;</span><br><span class="line">        Outer.Inner inner = <span class="keyword">new</span> Outer.Inner();<span class="comment">// 直接创建静态内部类对象</span></span><br><span class="line">        inner.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-局部内部类"><a href="#1-3-局部内部类" class="headerlink" title="1.3.局部内部类"></a>1.3.局部内部类</h3><ul>
<li>定义在外部类<strong>方法</strong>中，作用范围和创建对象范围仅限于当前方法</li>
<li>局部内部类访问外部类当前方法中的局部变量时，因无法保障变量的生命周期与自身相同，变量必须修饰为final</li>
<li>限制类的使用范围</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Outer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;<span class="comment">// 外部类</span></span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;刘德华&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String address = <span class="string">&quot;sz&quot;</span>;<span class="comment">// 定义局部变量</span></span><br><span class="line">        <span class="comment">//private String address = &quot;sz&quot;;//编译报错 不能加private</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 局部内部类：注意不能加任何访问修饰符</span></span><br><span class="line">        <span class="comment">//private class Inner&#123;//编译报错 不能加private之类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123; <span class="comment">//只能在show()方法中使用</span></span><br><span class="line">            <span class="keyword">private</span> String phone = <span class="string">&quot;114&quot;</span>;</span><br><span class="line">            <span class="keyword">private</span> String email = <span class="string">&quot;humble_zh@163.com&quot;</span>;</span><br><span class="line">            <span class="comment">//private static int count = 2000;//编译报错 不能定义static变量</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">2000</span>;<span class="comment">//编译通过 能定义常量</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">              <span class="comment">//访问外部类的属性</span></span><br><span class="line">              <span class="comment">//无重名，相当于Outer.this.name,如果show2()是static的,就不能直接访问</span></span><br><span class="line">              sout(name); <span class="comment">//刘德华</span></span><br><span class="line">              sout(Outer.<span class="keyword">this</span>.age); <span class="comment">//35</span></span><br><span class="line">              <span class="comment">// 访问内部类的属性</span></span><br><span class="line">              sout(phone); <span class="comment">//114</span></span><br><span class="line">              sout(<span class="keyword">this</span>.email); <span class="comment">//humble_zh@163.com</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">// 访问局部变量 jdk1.7要求必须常量final、jdk1.8自动添加final</span></span><br><span class="line">              sout(address); <span class="comment">//sz  //自动帮 String address = &quot;sz&quot;; 加了final</span></span><br><span class="line">              <span class="comment">//address = &quot;bj&quot;; //编译报错 final不能修改</span></span><br><span class="line">              <span class="comment">//为啥指定final？</span></span><br><span class="line">              <span class="comment">//show().address属于栈内，方法返回后变量就回收了</span></span><br><span class="line">              <span class="comment">//new Inner()的对象在堆，show()返回后，inner对象未回收，不能访问已被回收的address</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果没有下面2行，则没有任何输出</span></span><br><span class="line">      Inner inner = <span class="keyword">new</span> Inner();<span class="comment">//创建局部内部类对象</span></span><br><span class="line">      inner.show2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    psvm(String[] args)&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();<span class="comment">// 创建外部类对象</span></span><br><span class="line">        outer.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-匿名内部类"><a href="#1-4-匿名内部类" class="headerlink" title="1.4.匿名内部类"></a>1.4.匿名内部类</h3><ul>
<li>没有类名的局部内部类（一切特征都与局部内部类相同）</li>
<li>必须继承一个父类或者实现一个接口</li>
<li>定义类、实现类、创建对象的语法合并，只能创建一个该类的对象</li>
<li>优点：减少代码量</li>
<li>缺点可读性较差</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Usb.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Usb</span></span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Mouse.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">implements</span> <span class="title">Usb</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123; sout(<span class="string">&quot;成功连接电脑，Mouse开始工作&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TestUsb.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUsb</span></span>&#123;</span><br><span class="line">    psvm(String[] args)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Usb usb = new Mouse();//创建接口类型变量</span></span><br><span class="line"><span class="comment">        usb.service();//成功连接电脑，Mouse开始工作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* //局部内部类</span></span><br><span class="line"><span class="comment">        class Fan implements Usb&#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void service()&#123; sout(&quot;成功连接电脑，Fan开始工作&quot;) &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //使用局部内部类创建对象</span></span><br><span class="line"><span class="comment">        Usb usb = new Fan();</span></span><br><span class="line"><span class="comment">        usb.service(); //成功连接电脑，fan开始工作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//上面使用局部内部类，用完之后就不再用了，没必要定义一个带名字的类</span></span><br><span class="line">        <span class="comment">//使用匿名内部类优化（相当于创建了一个局部内部类）</span></span><br><span class="line">        <span class="comment">//Usb usb = new Usb(); //编译报错 interface 不能实例化</span></span><br><span class="line">        Usb usb = <span class="keyword">new</span> Usb()&#123; <span class="comment">//Usb() 可以是 interface, 抽象类, 父类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123; sout(<span class="string">&quot;成功连接电脑，xxx开始工作&quot;</span>) &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        usb.service(); <span class="comment">//成功连接电脑，xxx开始工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-Object-类"><a href="#2-Object-类" class="headerlink" title="2.Object 类"></a>2.Object 类</h2><ul>
<li>超类、基类，所有类的直接或间接父类，位于继承树的最顶层</li>
<li>任何类，如没有书写extends显示继承某个类，都默认直接继承Object类，否则为间接继承</li>
<li>Object类中所定义的方法，是所有对象都具备的方法</li>
<li>Object类型可以存储任何对象<ul>
<li>作为参数，可接受任何对象</li>
<li>作为返回值，可返回任何对象</li>
</ul>
</li>
</ul>
<p><code>clone(),equals(),finalize(),getClass(),hashCode(),notify(),notifyAll(),toString(),wait(),wait(timeout)</code></p>
<h3 id="getClass-方法"><a href="#getClass-方法" class="headerlink" title="getClass() 方法"></a>getClass() 方法</h3><ul>
<li><code>public final Class&lt;?&gt; getClass()&#123;&#125;</code></li>
<li>返回引用中存储的实际对象类型</li>
<li>应用：通常用于判断两个引用中实际存储对象类型是否一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Student s1=<span class="keyword">new</span> Student(<span class="string">&quot;aaa&quot;</span>,<span class="number">20</span>);</span><br><span class="line">Student s2=<span class="keyword">new</span> Student(<span class="string">&quot;bbb&quot;</span>,<span class="number">22</span>);</span><br><span class="line"><span class="comment">// getClass返回 class类型</span></span><br><span class="line">Class class1 = s1.getClass();</span><br><span class="line">Class class2 = s2.getClass();</span><br><span class="line"><span class="comment">// 判断s1 和 s2是不是同一个类型</span></span><br><span class="line"><span class="keyword">if</span>(class1 == class2)&#123; sout(<span class="string">&quot;true&quot;</span>); &#125;</span><br><span class="line"><span class="keyword">else</span>&#123; sout(<span class="string">&quot;false&quot;</span>); &#125;</span><br></pre></td></tr></table></figure>
<h3 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a>hashCode()方法</h3><ul>
<li><code>public int hashCode()&#123;&#125;</code></li>
<li>返回该对象的哈希码值</li>
<li>哈希值根据对象的<code>地址</code>或<code>字符串</code>或<code>数字</code>使用hash算法计算出来的int类型的值</li>
<li>一般情况下相同对象返回相同哈希码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student s1=<span class="keyword">new</span> Student(<span class="string">&quot;aaa&quot;</span>,<span class="number">20</span>);</span><br><span class="line">Student s2=<span class="keyword">new</span> Student(<span class="string">&quot;bbb&quot;</span>,<span class="number">22</span>);</span><br><span class="line">sout(s1.hashCode()); <span class="comment">//s1的hash和s2不相等</span></span><br><span class="line">sout(s2.hashCode()); <span class="comment">//因为是两个地址</span></span><br><span class="line">Student s3 = s1; <span class="comment">//s3和s1变量在栈内，但对象实例在堆</span></span><br><span class="line">sout(s3.hashCode());<span class="comment">//此时s3的hashCode与s1相同</span></span><br></pre></td></tr></table></figure>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><ul>
<li><code>public String toSring()&#123;&#125;</code></li>
<li>返回该对象的字符串表示（表现形式）</li>
<li>可以根据程序需求覆盖该方法，如：展示对象各个属性值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sout(s1.toString()); <span class="comment">// 直接打印包+类名+哈希值(hex)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在Student.java内重写toString()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 重写 alt + enter + s</span></span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;Student [name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age + <span class="string">&quot;]&quot;</span>; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sout(s1.toString()); <span class="comment">// 打印override后的格式</span></span><br></pre></td></tr></table></figure>
<h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h3><ul>
<li><code>public boolean equals(Object obj)&#123;&#125;</code></li>
<li>默认实现为(this == obj), 比较两个对象地址是否相同</li>
<li>可进行覆盖，比较两个对象的内容是否相同</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断两个对象是否相等</span></span><br><span class="line">sout(s1.equals(s2)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Student s4 = <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>, <span class="number">17</span>);</span><br><span class="line">Student s5 = <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>, <span class="number">17</span>);</span><br><span class="line">sout(s4.equals(s5)); <span class="comment">// false 堆中地址不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不想比较地址，那就在Student.java重写该方法为:比较内容</span></span><br><span class="line"><span class="comment">/* 步骤</span></span><br><span class="line"><span class="comment">   1. 比较两个应用是否指向同一个对象</span></span><br><span class="line"><span class="comment">   2. 判断obj是否为null</span></span><br><span class="line"><span class="comment">   3. 判断两个引用只想的实际对象类型是否一致</span></span><br><span class="line"><span class="comment">   4. 强制类型转换</span></span><br><span class="line"><span class="comment">   5. 依次比较各个属性值是否相同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">    <span class="comment">// 2.</span></span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">    <span class="comment">// 3.判断是否同一个类型</span></span><br><span class="line">    <span class="comment">//if(this.getClass() == obj.getClass())&#123;  &#125;</span></span><br><span class="line">    <span class="comment">//不想用getClass()可以用instanceof 判断对象是否是某种类型</span></span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">        <span class="comment">// 4.强制类型转换</span></span><br><span class="line">        Student s = (Student)obj;</span><br><span class="line">        <span class="comment">// 5. 比较属性</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.name.equals(s.getName()) &amp;&amp; <span class="keyword">this</span>.age == s.getAge())&#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写equals()之后下面调用就返回true</span></span><br><span class="line">sout(s4.equals(s5));</span><br></pre></td></tr></table></figure>
<p>//TODO<br><code>if(obj instanceof Student)</code>和<code>if(this.getClass() == obj.getClass())</code>这两个方法效果相同，一般用左边的。</p>
<p>但我觉得这两个方法判断的效果是不是不相同啊。<br>举个例子，Object——Person——Student这样的继承关系<br>Object obj = new Student（）；<br>Person person = new Person（）；<br>System.out.println(person.equals(obj));<br>如果用if(obj instanceof Person），那应该是True，因为obj是Student的实例，与Person有继承关系。</p>
<p>如果用if(this.getClass() == obj.getClass())，那应该是False，因为obj引用的是Student类，而person是Person类</p>
<p>感觉这里是不是还是用if(this.getClass() == obj.getClass())判断更好一点啊<br>还有后面有个小笔误，整数缓冲区那里integer3,4，后面是100，不是new Integer（100）<br>sout(content.length()); // 10<br>sout(content.charAt(content.length() - 1)); // 言<br>唔这里应该是20和1<br>是100；自动装箱相当于Integer.valueOf(100)；如果是new，不会进缓冲区，会打印false；<br>if(obj instanceof Person）这里的需求是需要判断两个类之间是否有直接或间接继承关系，不是判断是否一致；只有有继承关系，才能进行强制类型转换</p>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize() 方法"></a>finalize() 方法</h3><ul>
<li>当对象被判定为垃圾对象时，由JVM自动调用此方法，用以标记垃圾对象，进入回收队列</li>
<li>垃圾对象：没有有效引用指向此对象时，为垃圾对象</li>
<li>垃圾回收：由gc销毁垃圾对象，释放数据存储空间</li>
<li>自动回收机制：JVM的内存耗尽，一次性回收所有垃圾对象</li>
<li>手动回收机制：使用<code>System.gc();</code>通知JVM执行垃圾回收</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123; sout(<span class="keyword">this</span>.name + <span class="string">&quot;对象被回收了&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test.java</span></span><br><span class="line">psvm(String[] args)&#123;</span><br><span class="line">    Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;aaa&quot;</span>, <span class="number">20</span>); <span class="comment">// 不是垃圾</span></span><br><span class="line">    <span class="keyword">new</span> Student(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>); <span class="comment">// 是垃圾 会被回收</span></span><br><span class="line">    System.gc();<span class="comment">//手动调用，回收垃圾</span></span><br><span class="line">    sout(<span class="string">&quot;回收垃圾&quot;</span>);</span><br><span class="line">    <span class="comment">// 打印出</span></span><br><span class="line">    <span class="comment">//回收垃圾</span></span><br><span class="line">    <span class="comment">//bbb对象被回收了”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-包装类"><a href="#3-包装类" class="headerlink" title="3.包装类"></a>3.包装类</h2><ul>
<li><strong>基本数据类型</strong>所对应的<strong>引用数据类型</strong></li>
<li>Object 可统一所有数据，包装类的默认值是null</li>
</ul>
<p>基本数据类型在栈，自己没有方法调用（因为不是类）。包装成<code>引用数据类型</code>之后就是类，实例存在于堆。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类型</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody></table>
<h3 id="类型转换与装箱、拆箱"><a href="#类型转换与装箱、拆箱" class="headerlink" title="类型转换与装箱、拆箱"></a>类型转换与装箱、拆箱</h3><p>装箱：基本 转 引用 (栈-&gt;堆);拆箱相反。</p>
<ul>
<li>8种包装类提供不用类型间的转换方式<ol>
<li>Number父类中提供的6个共性方法</li>
<li><code>parseXXX( )</code>静态方法</li>
<li><code>valueOf( )</code>静态方法</li>
</ol>
</li>
<li>注意：需保证类型兼容，否则抛出NumberFormatException异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">psvm(String[] args)&#123;</span><br><span class="line">    <span class="comment">// 装箱， 基本类型 -&gt; 引用类型</span></span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">18</span>;<span class="comment">// 基本类型</span></span><br><span class="line">    <span class="comment">// 使用Integer类创建对象</span></span><br><span class="line">    Integer integer1 = <span class="keyword">new</span> Integer(num1); <span class="comment">//构造方法</span></span><br><span class="line">    Integer integer2 = Integer.valueOf(num1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拆箱， 引用类型 -&gt; 基本类型</span></span><br><span class="line">    Integer integer3 = <span class="keyword">new</span> Integer(<span class="number">100</span>); <span class="comment">//创建引用类型</span></span><br><span class="line">    <span class="keyword">int</span> num2 = integer3.intValue(); <span class="comment">//转成基本类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上述为jdk1.5之前方法，之后提供了自动装箱拆箱</span></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line">    Integer integer4 = age; <span class="comment">// 自动装箱 编译器自动补全为 integer4 = age.valueOf();</span></span><br><span class="line">    <span class="keyword">int</span> age2 = integer4; <span class="comment">// 自动拆箱 编译器自动补全为 age2 = integer4.intValue();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本类型和字符串之间转换</span></span><br><span class="line">    <span class="comment">// 1. 基本类型转成字符串</span></span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 1.1 使用+号</span></span><br><span class="line">    String s1 = n1 + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 1.2 使用Integer中的toString()方法</span></span><br><span class="line">    String s2 = Integer.toString(n1);</span><br><span class="line">    String s2 = Integer.toString(n1, <span class="number">16</span>);<span class="comment">//Integer.toString(n1, x); // x为进制要求</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 字符串转成基本类型</span></span><br><span class="line">    String str = <span class="string">&quot;150&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> n2 = Integer.parseInt(str); <span class="comment">// 使用Integer.parseXXX();</span></span><br><span class="line">    <span class="comment">//int n2 = Integer.parseInt(&quot;150o&quot;); // 编译报错 只能是数字字符不能是字母或其他</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// boolean 字符串形式转成基本类型，只有&quot;true&quot; -&gt; true,非“true&quot; -&gt; false</span></span><br><span class="line">    String str2 = <span class="string">&quot;true&quot;</span>;</span><br><span class="line">    <span class="keyword">boolean</span> b1 = Boolean.parseBoolean(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整数缓冲区"><a href="#整数缓冲区" class="headerlink" title="整数缓冲区"></a>整数缓冲区</h3><ul>
<li>Java预先创建了256个常用的证书包装类型对象</li>
<li>在实际应用当中，对已创建的对象进行复用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">psvm(String[] args)&#123;</span><br><span class="line">    <span class="comment">// 面试题</span></span><br><span class="line">    Integer integer1 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">    Integer integer2 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">    sout(integer1 == integer2); <span class="comment">// false 栈里面两个变量存的地址不相等</span></span><br><span class="line"></span><br><span class="line">    Integer integer3 = <span class="number">100</span>; <span class="comment">// 自动装箱 编译器自动补全为 =Integer.valueOf(100); //new Integer(100);</span></span><br><span class="line">    Integer integer4 = <span class="number">100</span>; <span class="comment">//编译器自动补全为 =Integer.valueOf(100);</span></span><br><span class="line">    sout(integer3 == integer4); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    Integer integer5 = <span class="number">200</span>; <span class="comment">// 自动装箱 编译器自动补全为 =Integer.valueOf(200); //new Integer(200);</span></span><br><span class="line">    Integer integer6 = <span class="number">200</span>; <span class="comment">//编译器自动补全为 =Integer.valueOf(200);//new Integer(200);</span></span><br><span class="line">    sout(integer5 == integer6); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 100在缓存区数组 [-128, 127] 内，故valueOf()返回的地址相同(共/复用同一个堆内的对象)</span></span><br><span class="line">    <span class="comment">// 200不在缓存区数组 [-128, 127] 内，故valueOf()返回 new Integer();的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">//堆:IntegerCache常量数组,范围[-128,127],若i在范围内,直接返回数组对应元素的地址</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) <span class="comment">//low:-128 high:127</span></span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-String-类"><a href="#4-String-类" class="headerlink" title="4.String 类"></a>4.String 类</h2><ul>
<li>字符串是常量，创建之后不可改变</li>
<li>字符串字面值存储在字符串池中，可以共享(内存分:栈、堆、方法区。字符串存在方法区的字符串池里)</li>
<li><code>String s = &quot;Hello&quot;;</code>产生一个对象，字符串池中存储</li>
<li><code>String s = new String(&quot;Hello&quot;);</code>产生两个对象，堆、池各一个</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">&quot;Hello&quot;</span>; <span class="comment">//name在栈，&quot;Hello&quot;在方法区的字符串池内</span></span><br><span class="line">name = <span class="string">&quot;zhangsan&quot;</span>; <span class="comment">//name在栈,更换指向为方法区的字符串池内的&quot;zhangsan&quot;,此时&quot;Hello&quot;成为了垃圾</span></span><br><span class="line">String name2 = <span class="string">&quot;zhangsan&quot;</span>; <span class="comment">//name2在栈和name指向同为方法区的字符串池内的&quot;zhangsan&quot;</span></span><br><span class="line"></span><br><span class="line">String s = <span class="string">&quot;Hello&quot;</span>; <span class="comment">//产生一个对象，字符串池中存储</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>); <span class="comment">//产生两个对象，堆和池 各一个;但堆内的对象指向的是方法区里的对象</span></span><br><span class="line"></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;java&quot;</span>); <span class="comment">//产生两个对象，堆和池 各一个 浪费空间</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;java&quot;</span>); <span class="comment">//产生两个对象，堆和池 各一个 浪费空间</span></span><br><span class="line">sout(str1==str2); <span class="comment">//false 因为堆内是两个实例，栈内的str1和str2保存的地址不一样</span></span><br><span class="line">sout(str1.equals(str2)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String content = &quot;java是世界上最好的编程语言&quot;;</span></span><br><span class="line">String content = <span class="string">&quot;java是世界上最好的java编程语言,java真香&quot;</span>;</span><br><span class="line">sout(content.length()); <span class="comment">// 15 // 1.int length(); 返回字符串长度</span></span><br><span class="line">sout(content.charAt(<span class="number">0</span>)); <span class="comment">// j // 2.char charAt(int index); 返回某个位置的字符</span></span><br><span class="line">sout(content.charAt(content.length() - <span class="number">1</span>)); <span class="comment">// 言</span></span><br><span class="line"><span class="comment">//sout(content.charAt(content.length())); //编译报错 访问越界</span></span><br><span class="line">sout(content.contains(<span class="string">&quot;java&quot;</span>)); <span class="comment">// true // 3.boolean contains(String str); 判断是否包含某个字符串</span></span><br><span class="line"></span><br><span class="line">sout(Arrays.toString(content.toCharArray())); <span class="comment">//[j,a...] //4.char[] toCharArray(); 返回字符串对应数组</span></span><br><span class="line">sout(content.indexOf(<span class="string">&quot;java&quot;</span>)); <span class="comment">//0 //5.int indexOf(String); 返回子字符串首次出现的下标,失败-1</span></span><br><span class="line">sout(content.indexOf(<span class="string">&quot;java&quot;</span>, <span class="number">4</span>)); <span class="comment">//从索引4开始找 返回11</span></span><br><span class="line">sout(content.lastIndexOf(<span class="string">&quot;java&quot;</span>)); <span class="comment">//12//6.int lastIndexOf(); 返回字符串最后一次出现的下标,失败-1</span></span><br><span class="line"></span><br><span class="line">String ct = <span class="string">&quot;   hello World   &quot;</span>;</span><br><span class="line">sout(ct.trim()); <span class="comment">// &quot;hello World&quot; // 7. trim(); //去掉字符串前后空格</span></span><br><span class="line">sout(ct.toUpperCase()); <span class="comment">// HELLO WORLD // 8. toUpperCase(); toLowerCase(); 转换大小写</span></span><br><span class="line">sout(ct.toLowerCase()); <span class="comment">// hello world</span></span><br><span class="line">sout(ct.endWith(<span class="string">&quot;World&quot;</span>)); <span class="comment">// true // 9. endWith(str); startWith(str);  判断是否以str 结尾、开头</span></span><br><span class="line">sout(ct.startWith(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. replace(char old, char new); 用new的字符或字符串替换old的字符或字符串</span></span><br><span class="line">sout(content.replace(<span class="string">&quot;java&quot;</span>, <span class="string">&quot;php&quot;</span>)); <span class="comment">// php是最好的语言...</span></span><br><span class="line"></span><br><span class="line">String say = <span class="string">&quot;java is the best    programing language,java xiang&quot;</span>;</span><br><span class="line">String[] arr = arr.say.split(<span class="string">&quot;[ ,]+ &quot;</span>); <span class="comment">// &quot;[ ,]+&quot; 表示空格 逗号切分 +号表示切分可以多个 比如多个空格 // 11. split(); 对字符串拆分</span></span><br><span class="line">sout(arr.length); <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">for</span>(String string : arr)&#123; sout(string); &#125;</span><br><span class="line"><span class="comment">// 打印出</span></span><br><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="comment">//is</span></span><br><span class="line"><span class="comment">//the</span></span><br><span class="line"><span class="comment">//best</span></span><br><span class="line"><span class="comment">//programing</span></span><br><span class="line"><span class="comment">//language</span></span><br><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="comment">//xiang</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 补充两个equals返回bool,compareTo()比较差值</span></span><br><span class="line">String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;HELLO&quot;</span>;</span><br><span class="line">sout(s1.equals(s2));<span class="comment">// false</span></span><br><span class="line">sout(s1.equalsIgnoreCase(s2));<span class="comment">//true 忽略大小写比较true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// compareTo(); 两字符不同时比较字符字典序的ascii码</span></span><br><span class="line">String s3=<span class="string">&quot;abc&quot;</span>; <span class="comment">//a:97</span></span><br><span class="line">String s4=<span class="string">&quot;xyz&quot;</span>; <span class="comment">//x:120</span></span><br><span class="line">sout(s3.compareTo(s4));<span class="comment">//-23</span></span><br><span class="line"></span><br><span class="line">String s5=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s6=<span class="string">&quot;abcxyz&quot;</span>;</span><br><span class="line">sout(s5.compareTo(s6));<span class="comment">//-3// 字符相同时返回长度差</span></span><br></pre></td></tr></table></figure>
<h3 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h3><p>需求：</p>
<ol>
<li>已知String str = “this is a text”;</li>
<li>将str中的单词单独获取</li>
<li>将str中的text替换成practice</li>
<li>在text前面插入一个easy</li>
<li>将每个单词的首字母改为大写</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">psvm(String[] args)&#123;</span><br><span class="line">    String str = <span class="string">&quot;this is a text&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String[] arr = str.split(<span class="string">&quot; &quot;</span>); <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">for</span>(String s : arr)&#123; sout(s); &#125;</span><br><span class="line"></span><br><span class="line">    String str2 = str.replace(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;practice&quot;</span>); <span class="comment">//2</span></span><br><span class="line">    String str3 = str.replace(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;easy text&quot;</span>); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123; <span class="comment">//4</span></span><br><span class="line">        <span class="keyword">char</span> first = arr[i].charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">char</span> upperfirst = Character.toUpperCase(first);</span><br><span class="line">        String newstr = upperfirst + arr[i].substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可变字符串"><a href="#可变字符串" class="headerlink" title="可变字符串"></a>可变字符串</h3><ul>
<li>StringBuffer : 可变长字符串，运行效率比String快，比StringBuilder慢、线程安全</li>
<li>StringBuilder : 可边长字符串、运行快、线程不安全</li>
</ul>
<p>效率都比String高且节省内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">psvm(String[] args)&#123;</span><br><span class="line">    <span class="comment">//StringBuffer sb = new StringBuffer();// StringBuffer 和 StringBuilder 用法一致</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();<span class="comment">// StringBuffer 和 StringBuilder 用法一致</span></span><br><span class="line">    sb.append(<span class="string">&quot;java no1&quot;</span>);<span class="comment">// 1. append(); 追加</span></span><br><span class="line">    sb.insert(<span class="number">0</span>, <span class="string">&quot;我在最前面&quot;</span>);<span class="comment">//我在最前面java no1 //2. insert(); 添加、插入</span></span><br><span class="line">    sb.replace(<span class="number">0</span>, <span class="number">5</span>, <span class="string">&quot;hello&quot;</span>); <span class="comment">//hellojava no1 //左闭右开// 3.replace(); 替换</span></span><br><span class="line">    sb.delete(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">//java no1 //左闭右开// 4. delete(); 删除</span></span><br><span class="line">    sb.delete(<span class="number">0</span>, sb.length());<span class="comment">// 5. 清空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证StringBuilder效率比String高</span></span><br><span class="line">psvm(String[] args)&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    String string = &quot;&quot;;</span></span><br><span class="line"><span class="comment">    for(int i=0; i &lt; 99999; i++)&#123; string+=i; &#125;</span></span><br><span class="line"><span class="comment">    sout(string); //总共用时47475ms</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">99999</span>; i++)&#123; sb.append(i); &#125;</span><br><span class="line">    sout(sb.toString()); <span class="comment">//总共用时308ms</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    sout(end-start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-BigDecimal-类"><a href="#5-BigDecimal-类" class="headerlink" title="5.BigDecimal 类"></a>5.BigDecimal 类</h2><ul>
<li>位置 <code>java.math</code> 包中</li>
<li>作用 精确计算浮点数</li>
<li>创建方式 <code>BigDecimal bd = new BigDecimal(&quot;1.0&quot;);</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//double在内存里存的是近似值,在要求精度比较高的场景(银行余额)就无法使用</span></span><br><span class="line"><span class="keyword">double</span> d1=<span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">double</span> d2=<span class="number">0.9</span>;</span><br><span class="line">sout(d1-d2);<span class="comment">//0.0999999...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> result=(<span class="number">1.4</span>-<span class="number">0.5</span>)/<span class="number">0.9</span>;</span><br><span class="line">sout(result);<span class="comment">//0.999999...</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bd1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>); <span class="comment">//传参需用字符串,因为数字本身是double就有可能不精确</span></span><br><span class="line">BigDecimal bd2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"></span><br><span class="line">BigDecimal r1 = bd1.subtract(bd2);<span class="comment">// 减法</span></span><br><span class="line">sout(r1); <span class="comment">// 0.1</span></span><br><span class="line"></span><br><span class="line">BigDecimal r2 = bd1.add(bd2);<span class="comment">//1.9 加法</span></span><br><span class="line"></span><br><span class="line">BigDecimal r3 = bd1.multiply(bd2);<span class="comment">//0.90 乘法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BigDecimal r4 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.4&quot;</span>).subtract(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.5&quot;</span>)).divide(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>));<span class="comment">//1 除法</span></span><br><span class="line">BigDecimal r5 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;20&quot;</span>).divide(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;3&quot;</span>), <span class="number">2</span>, BigDecimal.ROUND_HALF_UP);<span class="comment">//6.67 除不尽时 2:保留位数 ROUND_HALF_UP:为四舍五入</span></span><br></pre></td></tr></table></figure>
<h3 id="Date-类"><a href="#Date-类" class="headerlink" title="Date 类"></a>Date 类</h3><p>Date表示特定的瞬间，精确到毫秒。Date类中的大部分方法都已经被Calendar类中的方法所取代</p>
<p>时间单位：1s = 1,000ms = 1,000,000 μs = 1,000,000,000 = ns</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">psvm(String[] args)&#123;</span><br><span class="line">    Date date1 = <span class="keyword">new</span> Date();<span class="comment">// 1 创建Date对象 用java.util,java.sql是继承java.util的</span></span><br><span class="line">    sout(date1.toString()); <span class="comment">//SAT Jan 23 22:25:23 CST 2021</span></span><br><span class="line">    sout(date1.toLocaleString()); <span class="comment">// 已过时 但也能用 2021-1-23 22:25:24</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建昨天的</span></span><br><span class="line">    Date date2 = <span class="keyword">new</span> Date(date1.getTime() - (<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">1000</span>));</span><br><span class="line">    sout(date2.toLocaleString()); <span class="comment">//2021-1-22 22:25:24</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 方法after before</span></span><br><span class="line">    <span class="keyword">boolean</span> b1 = date1.after(date2);</span><br><span class="line">    sout(b1); <span class="comment">//true</span></span><br><span class="line">    <span class="keyword">boolean</span> b2 = date1.before(date2);</span><br><span class="line">    sout(b2); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d = date1.compareTo(date2);<span class="comment">// 比较compareTo();</span></span><br><span class="line">    sout(d); <span class="comment">// 大为1,小为-1,等为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> b3 = date1.equals(date2);<span class="comment">// 比较是否相等 equals()</span></span><br><span class="line">    sout(b3); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><ul>
<li>Calendar提供了获取或设置各种日历字段的方法</li>
<li>构造方法 <code>protected Calendar();</code> 由于是protected 所以无法直接创建</li>
<li>其他方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static Calendar getInstance()</td>
<td>使用默认时区和区域获取日历</td>
</tr>
<tr>
<td>void set(int year, int month, int date, int hourofday, int minute, int second)</td>
<td>设置日历的年、月、日、时、分、秒</td>
</tr>
<tr>
<td>int get(int field)</td>
<td>返回给定日历字段的值。字段比如年、月、日</td>
</tr>
<tr>
<td>void setTime(Date date)</td>
<td>用给定的date设置此日历时间</td>
</tr>
<tr>
<td>Date getTime()</td>
<td>返回一个date表示此日历的时间</td>
</tr>
<tr>
<td>void add(int field, int amount)</td>
<td>按照日历的规则，给指定字段添加或减少时间量</td>
</tr>
<tr>
<td>long getTimeInMilles()</td>
<td>毫秒为单位返回该日历的时间值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">psvm(String[] args)&#123;</span><br><span class="line">    Calendar calendar = Calendar.getInstance();<span class="comment">// 1. 创建 Calendar 对象</span></span><br><span class="line">    sout(calendar.getTime().toLocaleString());<span class="comment">//2021-01-23 16:16:05</span></span><br><span class="line">    sout(calendar.getTimeInMillis());</span><br><span class="line">    <span class="comment">// 2. 获取时间信息</span></span><br><span class="line">    <span class="keyword">int</span> year = calendar.get(Calendar.YEAR);<span class="comment">// 获取年</span></span><br><span class="line">    <span class="keyword">int</span> month = calendar.get(Calendar.MONTH);<span class="comment">// 获取月 从 0 - 11</span></span><br><span class="line">    <span class="keyword">int</span> month = calendar.get(Calendar.DAY_OF_MONTH);<span class="comment">// 日</span></span><br><span class="line">    <span class="keyword">int</span> hour = calendar.get(Calendar.HOUR_OF_DAY);<span class="comment">// HOUR_OF_DAY(24时制),HOUR(12时制)</span></span><br><span class="line">    <span class="keyword">int</span> minute = calendar.get(Calendar.MINUTE);<span class="comment">// 分钟</span></span><br><span class="line">    <span class="keyword">int</span> second = calendar.get(Calendar.SECOND);<span class="comment">// 秒</span></span><br><span class="line">    <span class="comment">// 3. 修改时间</span></span><br><span class="line">    Calendar calendar2 = Calendar.getInstance();</span><br><span class="line">    calendar2.set(Calendar.DAY_OF_MONTH, <span class="number">22</span>); <span class="comment">//时间改为今月的22号</span></span><br><span class="line">    <span class="comment">// 4. add修改时间</span></span><br><span class="line">    calendar2.add(Calendar.HOUR, <span class="number">1</span>); <span class="comment">// 1为加1小时 -1为减1小时</span></span><br><span class="line">    <span class="comment">// 5. 补充方法</span></span><br><span class="line">    <span class="keyword">int</span> max = calendar2.getActualMaximum(Calendar.DAY_OF_MONTH);<span class="comment">//31,月末一天</span></span><br><span class="line">    <span class="keyword">int</span> min = calendar2.getActualMinimum(Calendar.DAY_OF_MONTH);<span class="comment">//1,月初一天</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h3><ul>
<li>SimpleDateFormat是一个以与语言环境有关的方式来格式化和解析日期的具体类</li>
<li>进行格式化（日期-&gt;文本）、解析（文本-&gt;日期）</li>
<li>常用的时间模式字母</li>
</ul>
<table>
<thead>
<tr>
<th>字母</th>
<th>日期或时间</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年</td>
<td>2019</td>
</tr>
<tr>
<td>M</td>
<td>年中月份</td>
<td>08</td>
</tr>
<tr>
<td>d</td>
<td>月中天数</td>
<td>10</td>
</tr>
<tr>
<td>H</td>
<td>一天中小时（0-23）</td>
<td>22</td>
</tr>
<tr>
<td>m</td>
<td>分钟</td>
<td>16</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
<td>59</td>
</tr>
<tr>
<td>S</td>
<td>毫秒</td>
<td>356</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">psvm(String[] args) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<span class="comment">// 1. 创建对象</span></span><br><span class="line">    Date date = <span class="keyword">new</span> Date();<span class="comment">// 2. 创建Date</span></span><br><span class="line">    String str = sdf.format(date);<span class="comment">//格式化date（日期-&gt;字符串）</span></span><br><span class="line">    sout(str);<span class="comment">//2021-01-23 16:28:49</span></span><br><span class="line">    Date date2 = sdf.parse(<span class="string">&quot;2021-01-22 16:28:49&quot;</span>);<span class="comment">//解析(字符串-&gt;时间)若字符串不匹配创建对象时设定的格式就会抛出异常</span></span><br><span class="line">    sout(date2);<span class="comment">//Fri Jan 22 16:28:49 CST 2021</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-System类"><a href="#6-System类" class="headerlink" title="6.System类"></a>6.System类</h2><p>主要用于获取系统的属性数据和其他操作，构造方法私有的</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static void arraycopy(…)</td>
<td>复制数组</td>
</tr>
<tr>
<td>static long currentTimeMillis();</td>
<td>获取当前系统时间，返回毫秒值</td>
</tr>
<tr>
<td>static void gc();</td>
<td>建议jvm赶快启动垃圾回收期器回收垃圾</td>
</tr>
<tr>
<td>static void exit(int status);</td>
<td>退出jvm 如果参数是0表示正常退出jvm 非0表示异常退出</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">psvm(String[] args)&#123;</span><br><span class="line">    <span class="comment">//arraycopy 复制</span></span><br><span class="line">    <span class="comment">//src-原数组 srcPos-从哪个位置开始复制0 dest-目标数组 destPos-目标数组的位置 length-复制的长度</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">20</span>, <span class="number">18</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">35</span>, <span class="number">26</span>, <span class="number">45</span>, <span class="number">90</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dest = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">//System.arraycopy(arr, 0, dest, 0, 8);</span></span><br><span class="line">    System.arraycopy(arr, <span class="number">4</span>, dest, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dest.length; i++)&#123; sout(dest[i]); &#125;<span class="comment">//0, 0, 0, 0, 35, 26, 45, 90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Arrays.copyOf(original, newLength)底层就是调用System.arraycopy(),System.arraycopy()再底层就是用C/C++实现的</span></span><br><span class="line"></span><br><span class="line">    sout(System.currentTimeMillis());<span class="comment">//可用于计算代码用时</span></span><br><span class="line"></span><br><span class="line">    System.gc(); <span class="comment">//前面 finalize() 方法已经演示</span></span><br><span class="line"></span><br><span class="line">    System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2021/01/12/java%E5%AD%A6%E4%B9%A01_Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/">java学习1 Java零基础学习视频通俗易懂</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://humble-zh.github.io/page/5/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2021-01-12T06:05:42.000Z" itemprop="datePublished">2021-01-12</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/JAVA/" rel="tag">JAVA</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12J41137hu?from=search&seid=12777211954022913330">【狂神说Java】Java零基础学习视频通俗易懂</a></p>
<h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/humble/blog/<span class="built_in">source</span>/_posts/java on git:master x [18:27:56]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat Hello.java</span></span><br><span class="line">public class Hello&#123;</span><br><span class="line">    public static void main(String[] args)&#123; System.out.print(&quot;Hello World!&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/humble/blog/<span class="built_in">source</span>/_posts/java on git:master x [18:28:02]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> javac Hello.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/humble/blog/<span class="built_in">source</span>/_posts/java on git:master x [18:28:12]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">Hello.class  Hello.java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/humble/blog/<span class="built_in">source</span>/_posts/java on git:master x [18:28:13]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java Hello</span></span><br><span class="line">Hello World!%</span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/humble/blog/<span class="built_in">source</span>/_posts/java on git:master x [18:28:18]</span></span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>
<h1 id="Java数据类型分类"><a href="#Java数据类型分类" class="headerlink" title="Java数据类型分类"></a>Java数据类型分类</h1><h2 id="基本数据类型primitive-type"><a href="#基本数据类型primitive-type" class="headerlink" title="基本数据类型primitive type"></a>基本数据类型primitive type</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">byte num1 = 20;</span><br><span class="line">short num2 = 20;</span><br><span class="line">int num4 = 20;</span><br><span class="line">long num5 = 20L; //可以用L或l，但l容易跟1弄混</span><br><span class="line">float num6 = 50.1F;</span><br><span class="line">double num7 = 3.141592653;</span><br><span class="line">char num3 = &#x27;a&#x27;;</span><br><span class="line">boolean flag = true; //false</span><br></pre></td></tr></table></figure>
<h2 id="引用数据类型reference-type-类，接口，数组"><a href="#引用数据类型reference-type-类，接口，数组" class="headerlink" title="引用数据类型reference type(类，接口，数组)"></a>引用数据类型reference type(类，接口，数组)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = &quot;Lion&quot;;</span><br></pre></td></tr></table></figure>
<h1 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0b10010010 //二进制(0b)</span><br><span class="line">050 //八进制(0)</span><br><span class="line">0x1A //十六进制(0x)</span><br></pre></td></tr></table></figure>
<h2 id="避免使用浮点数比较，建议用类-BigDecimal"><a href="#避免使用浮点数比较，建议用类-BigDecimal" class="headerlink" title="避免使用浮点数比较，建议用类(BigDecimal)"></a>避免使用浮点数比较，建议用类(BigDecimal)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">float f = 0.1F;</span><br><span class="line">double d = 1.0/10;</span><br><span class="line">if(f == d)   //false</span><br><span class="line"></span><br><span class="line">float d1 = 123123123123123123F;</span><br><span class="line">float d2 = d1 + 1;</span><br><span class="line">if(d1 == d2) //true</span><br></pre></td></tr></table></figure>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//byte,short,char -&gt; int -&gt; long -&gt; float -&gt; double //低-&gt;高 (高-&gt;低:强制类型转换 低-&gt;高:自动类型转换)</span><br><span class="line">int i = 128;</span><br><span class="line">byte b = (byte)i; //-128 强制转换 内存溢出</span><br><span class="line">double d = i; //128 自动转换</span><br><span class="line">int j = (int)23.7; //23</span><br><span class="line">int k = (int)-45.89f; //-45</span><br><span class="line">int money = 10_0000_0000; //1000000000, JDK7新特性，可以用下划线分割数字</span><br><span class="line">long total = money * 12; //int型溢出，改为 long total = (long)money * 12L;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>不能对boolean进行转换</li>
<li>不能把对象类型转成不相干的类型(把猪转人-no,把男转女-yes)</li>
<li>把高容量转低容量时，强制转换</li>
<li>转换时可能存在内存溢出或精度问题</li>
</ul>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul>
<li>类变量：(static)初始默认值是null</li>
<li>实例变量：从属于对象，若不初始化，默认值是 0/0.0</li>
<li>局部变量：必须声明和初始化</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Variable&#123;</span><br><span class="line">    static int allClicks = 0; //类变量</span><br><span class="line">    String str=&quot;hello world&quot;; //实例变量</span><br><span class="line"></span><br><span class="line">    public void method()&#123;</span><br><span class="line">        int i=0; //局部变量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final double PI=3.14; //常量名建议使用全大写</span><br><span class="line"></span><br><span class="line">/* 修饰符关键字不分先后顺序 */</span><br><span class="line">static final double PI=3.14;</span><br><span class="line">final static double PI=3.14;</span><br></pre></td></tr></table></figure>
<h1 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h1><ul>
<li>类成员变量：首字母小写驼峰命名法</li>
<li>局部变量：首字母小写驼峰命名法</li>
<li>常量：大写字母和下划线</li>
<li>类名：首字母大写驼峰命名法</li>
<li>方法名：首字母小写驼峰命名法</li>
</ul>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ul>
<li>算数运算符<code>+,-,*,/,%,++,--</code></li>
<li>赋值运算符<code>=</code></li>
<li>关系运算符<code>&gt;,&lt;,&gt;=,&lt;=,==,!=,instanceof</code></li>
<li>逻辑运算符<code>&amp;&amp;,||,!</code></li>
<li>位运算符<code>&amp;,|,^,~,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;</code></li>
<li>条件运算符<code>? :</code></li>
<li>扩展赋值运算符<code>+=,-=,*=,/=</code></li>
</ul>
<p>IDEAtips:<code>Ctrl+d</code>是复制当前行到下一行</p>
<p>短路运算</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int c=5;</span><br><span class="line">boolean d = (c&lt;4)&amp;&amp;(c++&lt;4); //d是false,c是5</span><br></pre></td></tr></table></figure>
<p>字符串连接符号<code>+</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">int b=20;</span><br><span class="line">&quot;&quot;+a+b //&quot;1020&quot;</span><br><span class="line">a+b+&quot;&quot; //&quot;30&quot;</span><br></pre></td></tr></table></figure>
<h1 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h1><p>是为了更好地组织类，并且区别类名的命名空间。常用公司域名倒置作为包名:<code>com.baidu.www</code>。package用来封装包，import用来导入包（import需要放置在package后面）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package pkg1[. pkg2[. pkg3... ]];</span><br><span class="line">import package1[.package2...].(classname|*); //*是通配符，表示导入包下所有的类</span><br></pre></td></tr></table></figure>
<p>IDEAtips：需要用外部包的变量或方法时报错忘记import，按<code>Alt+Enter</code>可查询包方便导入</p>
<h1 id="JavaDoc"><a href="#JavaDoc" class="headerlink" title="JavaDoc"></a>JavaDoc</h1><p>javadoc命令是用来生成自己API文档的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">参数信息</span><br><span class="line">  <span class="meta">@author</span> 作者名</span><br><span class="line">  <span class="meta">@version</span> 版本号</span><br><span class="line">  <span class="meta">@since</span> 指明需要最早适用的jdk版本</span><br><span class="line">  <span class="meta">@param</span> 参数名</span><br><span class="line">  <span class="meta">@return</span> 返回值情况</span><br><span class="line">  <span class="meta">@throws</span> 异常抛出情况</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.humble.base;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author humble</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @since 1.8</span><br><span class="line"> */</span><br><span class="line">public class Hello &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public String test(String name) throws Exception&#123; return name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在idea里右键Hello的类，<code>Show in Files</code>，在当前目录打开命令行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src/com/humble/base [23:19:05]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">Hello.java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src/com/humble/base [23:19:07]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> javadoc -encoding UTF-8 -charset UTF-8 Hello.java</span></span><br><span class="line">正在加载源文件Hello.java...</span><br><span class="line">正在构造 Javadoc 信息...</span><br><span class="line">标准 Doclet 版本 1.8.0_265</span><br><span class="line">正在构建所有程序包和类的树...</span><br><span class="line">正在生成./com/humble/base/Hello.html...</span><br><span class="line">Hello.java:17: 警告 - @return 标记没有参数。</span><br><span class="line">正在生成./com/humble/base/package-frame.html...</span><br><span class="line">正在生成./com/humble/base/package-summary.html...</span><br><span class="line">正在生成./com/humble/base/package-tree.html...</span><br><span class="line">正在生成./constant-values.html...</span><br><span class="line">正在构建所有程序包和类的索引...</span><br><span class="line">正在生成./overview-tree.html...</span><br><span class="line">正在生成./index-all.html...</span><br><span class="line">正在生成./deprecated-list.html...</span><br><span class="line">正在构建所有类的索引...</span><br><span class="line">正在生成./allclasses-frame.html...</span><br><span class="line">正在生成./allclasses-noframe.html...</span><br><span class="line">正在生成./index.html...</span><br><span class="line">正在生成./help-doc.html...</span><br><span class="line">1 个警告</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src/com/humble/base [23:19:47]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">allclasses-frame.html    Hello.java          package-list</span><br><span class="line">allclasses-noframe.html  help-doc.html       script.js</span><br><span class="line">com                      index-all.html      stylesheet.css</span><br><span class="line">constant-values.html     index.html</span><br><span class="line">deprecated-list.html     overview-tree.html</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src/com/humble/base [23:21:36]</span></span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>
<p>用浏览器打开<code>index.html</code>即可</p>
<h1 id="Scanner对象"><a href="#Scanner对象" class="headerlink" title="Scanner对象"></a>Scanner对象</h1><p>用于获取用户输入</p>
<h2 id="Demo01-使用next"><a href="#Demo01-使用next" class="headerlink" title="Demo01:使用next()"></a><code>Demo01</code>:使用<code>next()</code></h2><ul>
<li>1.一定要读取到有效字符后才可以结束输入</li>
<li>2.对输入有效字符前遇到的空白，next()方法会自动将其去掉</li>
<li>3.只有输入有效字符后才将其后面输入的空白作为分隔符或结束符</li>
<li>4.next()不能得到带有空格的字符串</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.humble.scanner;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建扫描器对象，用于接收键盘数据</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;使用next方式接收：&quot;);</span><br><span class="line"></span><br><span class="line">        if(scanner.hasNext())&#123; //判断用户有没有输入字符串</span><br><span class="line">            //使用next方式接收</span><br><span class="line">            String str = scanner.next(); //程序会等待用户输入完毕</span><br><span class="line">            System.out.println(&quot;输入内容为：&quot; + str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //凡是属于IO流的类，如果不关闭会一直占用资源，要养成良好习惯，用完就关</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行Demo01(只输出了空格前的单词,再调用next()可获得下一个单词)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用next方式接收：</span><br><span class="line">hello world!</span><br><span class="line">输入内容为：hello</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<h2 id="Demo02-使用nextLine"><a href="#Demo02-使用nextLine" class="headerlink" title="Demo02:使用nextLine()"></a><code>Demo02</code>:使用<code>nextLine()</code></h2><ul>
<li>1.以Enter为结束符，即返回的是回车之前的全部字符</li>
<li>2.可以获得空白字符</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.humble.scanner;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Demo02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;使用nextline方式接收：&quot;);</span><br><span class="line">        if(scanner.hasNextLine())&#123;</span><br><span class="line">            //使用nextline方式接收</span><br><span class="line">            String str = scanner.nextLine(); //程序会等待用户输入完毕</span><br><span class="line">            System.out.println(&quot;输入内容为：&quot; + str);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行Demo02(输出整行)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用nextline方式接收：</span><br><span class="line">hello world!</span><br><span class="line">输入内容为：hello world!</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<h1 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h1><p><code>Project Structure</code>-<code>Project Settings</code>-<code>Project</code>-<code>Project comcompiler output</code><br>打开对应目录，子目录里面会有<code>.class</code>文件，把class文件拷贝到项目目录，然后导入到idea即可看到源码</p>
<p>IDEAtips:输入<code>100.for</code>即可补全for循环100次</p>
<h1 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h1><p>重载就是在一个类中，有相同的方法名称，但形参不同的方法。</p>
<p>重载规则：</p>
<ul>
<li>1.方法名称必须相同</li>
<li>2.参数列表必须不同（个数不同、类型不同、参数排列不同等）</li>
<li>3.方法的返回类型可以相同也可不同</li>
<li>4.仅仅返回类型不同不足以成为方法的重载</li>
</ul>
<p>实现理论：方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</p>
<h1 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.humble.base;</span><br><span class="line"></span><br><span class="line">public class Hello &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">            System.out.println(&quot;arg[&quot; + &quot;] is &quot; + args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src/com/humble/base [16:19:41]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">Hello.java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src/com/humble/base [16:19:41]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> javac Hello.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src/com/humble/base [16:19:47]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">Hello.class  Hello.java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src/com/humble/base [16:20:07]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ../../../</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src [16:20:12]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src [16:20:13]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java com.humble.base.Hello</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src [16:20:28]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java com.humble.base.Hello this is argv</span></span><br><span class="line">arg[] is this</span><br><span class="line">arg[] is is</span><br><span class="line">arg[] is argv</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/IdeaProjects/StudyJAVA/Hello/src [16:20:38]</span></span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>
<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><ul>
<li>JDK1.5开始，java支持：给一个方法传递同类型的可变参数</li>
<li>在方法声明中，在指定参数类型后面加一个省略号(…)</li>
<li>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</li>
</ul>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归结构包括两个部分：</p>
<ul>
<li>递归头：什么时候不调用自身方法。如果没有头，将陷入死循环。</li>
<li>递归体：什么时候需要调用自身方法。</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar; //首选</span><br><span class="line">dataType arrayRefVar[]; //只是为了方便C/C++程序员</span><br><span class="line">dataType[] arrayRefVar = new dataType[arraySize];</span><br></pre></td></tr></table></figure>
<p>三种初始化</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//静态初始化</span><br><span class="line">int[] a = &#123;1,2,3&#125;;</span><br><span class="line">Man[] mans = &#123;new Man(1,1), new Man(2,2)&#125;;</span><br><span class="line"></span><br><span class="line">//动态初始化</span><br><span class="line">int[] a = new int[2];</span><br><span class="line">a[0] = 1;</span><br><span class="line">a[1] = 2;</span><br><span class="line"></span><br><span class="line">//数组默认初始化：数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中每个元素也被按照实例变量同样的方式被隐式初始化。</span><br></pre></td></tr></table></figure>
<h1 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h1><p>数组本身没有什么方法提供调用，但API中提供了工具类<code>java.util.Arrays</code>对数据对象进行一些基本操作。<code>Arrays</code>类中的方法都是<code>Static</code>修饰的静态方法，使用时可以直接用类名调用，不需要使用对象来调用（想用对象也可以）。</p>
<ul>
<li>给数组赋值用<code>fill</code>方法</li>
<li>对数组排序用<code>sort</code>方法，按升序</li>
<li>比较数组用<code>equals</code>，比较元素值是否相等</li>
<li>查找数组元素用<code>binarySearch</code>，对排好序的数组进行二分发查找</li>
</ul>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static int[] sort(int[] a)&#123;</span><br><span class="line">    int tmp = 0;</span><br><span class="line">    boolean flag = false; //假设已经排好序，即无需位置交换</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; a.length - 1; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; a.length - 1 - i; j++) &#123;</span><br><span class="line">            if(a[j+1] &lt; a[j])&#123;</span><br><span class="line">                tmp = a[j];</span><br><span class="line">                a[j] = a[j+1];</span><br><span class="line">                a[j+1] = tmp;</span><br><span class="line">                flag = true; //表示有位置交换</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /* 确实没有发生位置交换，表示已经排好序 */</span><br><span class="line">        if(!flag)&#123; break; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h1><p>当数组中大部分元素为0,或者为同一值时，可以使用稀疏数组来保存。处理方式是：</p>
<ul>
<li>记录数组一共几行几列几个非0值</li>
<li>把具有不同值的元素和行列及值记录在一个小规模数组中，从而压缩数据</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[][] array1 = new int[11][11];</span><br><span class="line">        array1[1][2] = 1;</span><br><span class="line">        array1[2][3] = 2;</span><br><span class="line">        for (int[] ints : array1) &#123; //打印原数组</span><br><span class="line">            for (int anInt : ints) &#123; System.out.print(anInt); &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;==开始转为稀疏数组==&quot;);</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int[] ints : array1) &#123; //统计非0总数</span><br><span class="line">            for (int anInt : ints) &#123;</span><br><span class="line">                if(anInt != 0) &#123; sum++; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //总长、总宽、非0总数</span><br><span class="line">        int[][] array2 = new int[sum+1][3];</span><br><span class="line">        array2[0][0] = array1[0].length;</span><br><span class="line">        array2[0][1] = array1.length;</span><br><span class="line">        array2[0][2] = sum;</span><br><span class="line"></span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; array1.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; array1[i].length; j++) &#123;</span><br><span class="line">                if(array1[i][j] != 0)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    array2[count][0] = i;</span><br><span class="line">                    array2[count][1] = j;</span><br><span class="line">                    array2[count][2] = array1[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;cow\trow\tvalue&quot;);</span><br><span class="line">        for (int[] ints : array2) &#123; System.out.println(Arrays.toString(ints)); &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;==开始还原数组==&quot;);</span><br><span class="line">        int[][] array3 = new int[array2[0][0]][array2[0][1]];</span><br><span class="line">        for (int i = 1; i &lt; array2.length; i++) &#123;</span><br><span class="line">            array3[array2[i][0]][array2[i][1]] = array2[i][2];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int[] ints : array1) &#123;</span><br><span class="line">            for (int anInt : ints) &#123; System.out.print(anInt); &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">00000000000</span><br><span class="line">00100000000</span><br><span class="line">00020000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">==开始转为稀疏数组==</span><br><span class="line">cow	row	value</span><br><span class="line">[11, 11, 2]</span><br><span class="line">[1, 2, 1]</span><br><span class="line">[2, 3, 2]</span><br><span class="line">==开始还原数组==</span><br><span class="line">00000000000</span><br><span class="line">00100000000</span><br><span class="line">00020000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br><span class="line">00000000000</span><br></pre></td></tr></table></figure>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><ul>
<li>对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是具体到微观操作，仍然需要面向过程的思路取处理。</li>
<li>面向对象编程（Object-Oriented Programming），本质是：以类的方式组织代码，以对象的方式组织/封装数据。</li>
<li>三大特性：封装、继承、多态。</li>
<li>从认识的角度考虑是先有对象后有类。对象是具体的事物；类是针对对象的抽象。</li>
<li>从代码运行角度考虑是先有类后有对象。类是对象的模板。</li>
</ul>
<h1 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h1><ul>
<li>带<code>static</code>：方法在类定义时就已经加载，所以其它地方可以直接用<code>类名</code>调用方法。</li>
<li>非<code>static</code>：方法在对象定义时才加载，所以其它地方必须先实例化才能用实例（<code>对象</code>）调用方法。</li>
<li>定义类时，在<code>static</code>方法内调用自己的<code>非static</code>方法会失败；在<code>非static</code>方法内可以直接调用自己的<code>非static</code>方法。</li>
</ul>
<h1 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h1><p>java里面调用方法都是<code>值传递</code>，不是<code>引用传递</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person();</span><br><span class="line">        System.out.println(person.name); //未定义所以打印 null</span><br><span class="line">        Hello.change(person); //传了对象（引用传递，址传递）</span><br><span class="line">        System.out.println(person.name); //打印出 world</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void change(Person person)&#123; person.name = &quot;world&quot;; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123; String name; &#125;</span><br></pre></td></tr></table></figure>
<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><ul>
<li>类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但不能代表某一个具体的事物。</li>
<li>对象是抽象概念的具体实例。</li>
<li>使用new关键字创建对象时，除了分配内存空间，还会给对象进行默认的初始化以及对类中构造器的调用。</li>
</ul>
<h1 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h1><ul>
<li>类中的构造器也称构造方法，是在进行创建对象的时候必须要调用的，目的在于初始化值。</li>
<li>没有人为初始化则默认为：<code>数字(0,0.0),char(u0000),boolean(false),引用(null)</code></li>
<li>构造器有两个特点：1.必须和类的名字相同，2.必须没有返回类型，也不能写void。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Application.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //Person humble = new Person(); //Person()实际上是构造方法</span><br><span class="line">        Person humble = new Person(&quot;Humble&quot;);</span><br><span class="line">        System.out.println(humble.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Person.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    //即使留空，默认也会存在一个无参构造方法Person()</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    String name;</span><br><span class="line">    //显式定义无参构造方法</span><br><span class="line">    public Person()&#123; this.name = &quot;hello&quot;; &#125;</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    /*</span><br><span class="line">    当底下定义了带参构造方法，那其它地方就无法使用无参构造方法来创建实例</span><br><span class="line">    如果想保留无参构造方法，只需显式定义一下无参构造方法即可</span><br><span class="line">     */</span><br><span class="line">    public Person()&#123; &#125;</span><br><span class="line"></span><br><span class="line">    //定义有参构造方法</span><br><span class="line">    public Person(String name)&#123; this.name = name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IDEAtips:<code>Alt+Insert</code>-<code>Constructor</code>-选择属性或不选属性-<code>OK</code>即可光标处快速生成构造方法</p>
<h1 id="创建对象内存分析"><a href="#创建对象内存分析" class="headerlink" title="创建对象内存分析"></a>创建对象内存分析</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内存</span><br><span class="line">├── 栈(stack)</span><br><span class="line">└── 堆(heap)</span><br><span class="line">    ├── new分配区</span><br><span class="line">    └── 方法区</span><br><span class="line">        └── 静态方法区</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //new会在堆的new分配区申请一片内存并返回地址</span><br><span class="line">        //person变量保存在栈，它的值是一个指向堆的地址</span><br><span class="line">        Person person = new Person();</span><br><span class="line">        System.out.println(person.name); //未定义所以打印 null</span><br><span class="line">        Hello.change(person); //传了对象（引用传递，址传递）</span><br><span class="line">        System.out.println(person.name); //打印出 world</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void change(Person person)&#123;</span><br><span class="line">        //person虽然是值传递，但传的却是地址值（引用值）</span><br><span class="line">        //地址指向的是堆内new分配区的对象空间</span><br><span class="line">        person.name = &quot;world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123; String name; &#125;</span><br></pre></td></tr></table></figure>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><ul>
<li>程序设计应该“高内聚，低耦合”。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合是仅暴露少量的方法给外部使用。</li>
<li>信息隐藏：禁止别人直接访问对象中的数据，而应该通过操作接口来访问。</li>
<li>属性私有：get()或set()</li>
</ul>
<p>封装的好处：</p>
<ol>
<li>提高程序的安全性，保护数据</li>
<li>隐藏代码实现细节</li>
<li>统一接口</li>
<li>增加系统可维护性</li>
</ol>
<p>IDEAtips:<code>Alt+Insert</code>-<code>Getter and Setter</code>-选择属性或不选属性-<code>OK</code>即可光标处快速生成<code>get()</code>和<code>set()</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123; return name; &#125;</span><br><span class="line">    public void setName(String name) &#123; this.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123; return age; &#125;</span><br><span class="line">    public void setAge(int age) &#123; //用set修改私有属性可以保护数据合法性</span><br><span class="line">        if(age &gt; 120 || age &lt; 0)&#123; this.age = 3; &#125;</span><br><span class="line">        else &#123; this.age = age; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123; return id; &#125;</span><br><span class="line">    public void setId(int id) &#123; this.id = id; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul>
<li>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。</li>
<li><code>extends</code>意思是扩展。子类是父类的扩展。</li>
<li>java中类只有单继承，没有多继承。</li>
<li>继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字extends来表示。子类和父类之间，从意义上讲应该具有”is a”的关系。</li>
<li>继承是类和类之间的一种关系。除此之外，类和类之间的关系还有<code>依赖、组合、聚合</code>等。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Student extends Person &#123; &#125; //Student继承Person</span><br><span class="line">public class Student &#123; //Student和person是组合关系</span><br><span class="line">    Person person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="继承例程"><a href="#继承例程" class="headerlink" title="继承例程"></a>继承例程</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Person.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    //public:可以被子类继承</span><br><span class="line">    //protected: 可被子继承</span><br><span class="line">    //default:(不加修饰就是这个)</span><br><span class="line">    //private:不可被子类继承(提供public get()/set())</span><br><span class="line"></span><br><span class="line">    protected int money = 10_0000_0000;</span><br><span class="line">    public void say() &#123; System.out.println(&quot;I am a Person&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package com.oop.demo;</span><br><span class="line">public class Student extends Person &#123; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Application.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student s1 = new Student();</span><br><span class="line">        System.out.println(s1.money); //1000000000</span><br><span class="line">        s1.say(); //I am a Person</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IDEAtips:<code>Ctrl+h</code>可以打开继承树</p>
<p>java中所有的类都默认直接或间接继承<code>Object类</code></p>
<h1 id="super"><a href="#super" class="headerlink" title="super"></a>super</h1><ul>
<li>super()调用父类的构造方法，必须在构造方法的第一行</li>
<li>super只能出现在’子类’的方法或构造方法中</li>
<li>super和this不能同时调用构造方法</li>
</ul>
<h2 id="用super调用父类"><a href="#用super调用父类" class="headerlink" title="用super调用父类"></a>用super调用父类</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Person.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Person &#123; //如果修饰改为private，那么子类就无法用super直接调用</span><br><span class="line">    protected String name = &quot;person1&quot;;</span><br><span class="line">    public void print()&#123; System.out.println(&quot;Person.print&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Student.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Student extends Person &#123;</span><br><span class="line">    private String name = &quot;student1&quot;;</span><br><span class="line"></span><br><span class="line">    public void test(String name)&#123;</span><br><span class="line">        System.out.println(name); //$&#123;name&#125;</span><br><span class="line">        System.out.println(this.name); //student1</span><br><span class="line">        System.out.println(super.name); //person1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print()&#123; System.out.println(&quot;Student.print&quot;); &#125;</span><br><span class="line">    public void test1()&#123;</span><br><span class="line">        print(); //Student.print</span><br><span class="line">        this.print();//Student.print</span><br><span class="line">        super.print();//Person.print</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Application.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student s1 = new Student();</span><br><span class="line">        s1.test(&quot;hello&quot;);</span><br><span class="line">        s1.test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*运行输出</span><br><span class="line">hello</span><br><span class="line">student1</span><br><span class="line">person1</span><br><span class="line">Student.print</span><br><span class="line">Student.print</span><br><span class="line">Person.print</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h2 id="super构造器"><a href="#super构造器" class="headerlink" title="super构造器"></a>super构造器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Person.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    public Person()&#123; System.out.println(&quot;Person.Person&quot;); &#125;</span><br><span class="line">    public Person(String name)&#123; System.out.println(&quot;Person.Person:&quot;+name); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Student.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Student extends Person &#123;</span><br><span class="line">    public Student() &#123;</span><br><span class="line">        //隐藏调用，默认会先调用父类构造器super()。</span><br><span class="line">        //如果想显式调用super()则必须放在子类构造器第一行。</span><br><span class="line">        //若父类构造器有参，那么调用super()要带参，除非父类构造器重载</span><br><span class="line">        //super();</span><br><span class="line">        super(&quot;hello&quot;);</span><br><span class="line">        System.out.println(&quot;Student.Student&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Application.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123; Student s1 = new Student(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*运行输出</span><br><span class="line">Person.Person:hello</span><br><span class="line">Student.Student</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>为什么需要方法重写？（父类的功能，子类不一定需要或不一定满足）</p>
<p>方法重写注意：</p>
<ul>
<li><ol>
<li>需要继承关系，子类重写父类的方法；</li>
</ol>
</li>
<li><ol start="2">
<li>只针对方法，不能是属性，并且是‘对象的方法（即非<code>static</code>修饰的）’，不是‘类的方法’，；</li>
</ol>
</li>
<li><ol start="3">
<li>方法名必须相同；</li>
</ol>
</li>
<li><ol start="4">
<li>返回值与参数列表及类型必须相同（否则就是重载了）；</li>
</ol>
</li>
<li><ol start="5">
<li>修饰符：范围可以扩大但不能缩小（即父用<code>public</code>修饰那么子重写时就不能用<code>protected</code>或更小的来修饰），<code>public</code>&gt;<code>protected</code>&gt;<code>default</code>&gt;<code>private</code>；正常情况不会是<code>private</code>，因为这个方法不能用对象去调用，所以只要不是<code>private</code>都可以被子重写。</li>
</ol>
</li>
<li><ol start="6">
<li>抛出的异常：范围可以被缩小但不能扩大；<code>ClassNotFoundException</code>(小)–&gt;<code>Exception</code>(大)</li>
</ol>
</li>
</ul>
<p>例子1：带<code>static</code>方法（类的方法）该例子不是方法重写</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: B.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class B &#123;</span><br><span class="line">    public static void test()&#123; System.out.println(&quot;B.test&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: A.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class A extends B &#123;</span><br><span class="line">    public static void test()&#123; System.out.println(&quot;A.test&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Application.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //类里面的static方法应该用类去调用，这里用对象去调用是为了测试</span><br><span class="line">        A a = new A();</span><br><span class="line">        a.test(); //最终调用类的方法</span><br><span class="line"></span><br><span class="line">        //父类的引用指向子类</span><br><span class="line">        B b = new A();</span><br><span class="line">        b.test(); //最终调用类的方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*运行输出如下，说明方法的调用只和定义的数据类型有关，跟new A()无关</span><br><span class="line">A.test</span><br><span class="line">B.test</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>例子2：不带<code>static</code>方法（对象的方法）该例子是方法重写</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: B.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class B &#123;</span><br><span class="line">    public /*static*/ void test()&#123; System.out.println(&quot;B.test&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: A.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class A extends B &#123;</span><br><span class="line">    @Override //@表示注解，是有功能的注释。Override表示重写</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        //super.test(); //默认是调用父类的方法，现在重写</span><br><span class="line">        System.out.println(&quot;A.test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Application.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A a = new A();</span><br><span class="line">        a.test(); //最终调用对象的方法</span><br><span class="line"></span><br><span class="line">        B b = new A();</span><br><span class="line">        b.test(); //最终调用对象的方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*运行输出如下，只要是new A()就是调用重写后的方法</span><br><span class="line">A.test</span><br><span class="line">A.test</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>IDEAtips:<code>Alt+Insert</code>选<code>Override Methods</code></p>
<p>类的方法优先级高于对象的方法。</p>
<ul>
<li>例子1里面，<code>static</code>修饰的是类方法。<code>b.test()</code>调用的是<code>B类</code>的<code>test()</code>，(堆里面静态方法区)</li>
<li>例子2里面，无<code>static</code>修饰是对象方法。<code>b.test()</code>调用的是<code>对象b</code>的<code>test()</code>，但<code>对象b</code>是<code>A类</code>new出来的，(堆里面new分配区)</li>
</ul>
<h1 id="重载与重写区别："><a href="#重载与重写区别：" class="headerlink" title="重载与重写区别："></a>重载与重写区别：</h1><ul>
<li>重载是同一类里，方法名相同，参数个数或类型不同。</li>
<li>重写是子父类间，子类重写父类的方法，方法名及参数一模一样，方法体不一样。并且不能是类方法，即不能用<code>static</code>修饰。</li>
</ul>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul>
<li>同一个方法根据调用对象的不同而采取不同的行为方式。</li>
<li>其中调用对象的类型需要在执行过程中才能决定。</li>
<li>一个对象的实际类型是确定的（堆的new分配区），但是指向它的引用（栈）可以是其他类型（父类或关系类）</li>
</ul>
<p>注意事项：</p>
<ul>
<li>1.多态是针对方法的，不能是属性。</li>
<li>2.必须有父子关系（继承），否则引用不能转换，比如<code>String s4 = new Student();</code> 转换异常ClassCastException</li>
<li>3.存在条件：必须父子关系（继承）；方法需要重写（只有运行时才知道调用父方法还是子重写的方法）；父类引用指向子类；</li>
</ul>
<p>不能被子重写的方法：</p>
<ul>
<li>1.<code>static</code>方法，属于类，不属于实例</li>
<li>2.<code>final</code>常量，</li>
<li>3.<code>private</code>方法（因为不能继承）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Person.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Person &#123; public void run()&#123; System.out.println(&quot;Person.run&quot;); &#125; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Student.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Student extends Person &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123; System.out.println(&quot;Student.run&quot;); &#125;</span><br><span class="line"></span><br><span class="line">    public void eat()&#123; System.out.println(&quot;Student.eat&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Application.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student s1 = new Student();</span><br><span class="line">        Person s2 = new Student();</span><br><span class="line">        Object s3 = new Student();</span><br><span class="line">        //String s4 = new Student(); //报错，引用只能是同类或父类</span><br><span class="line"></span><br><span class="line">        //如果Student没有Override run方法，那两个都是Person.run</span><br><span class="line">        //如果Student有Override run方法，那两个都是Student.run</span><br><span class="line">        s1.run();</span><br><span class="line">        s2.run();</span><br><span class="line">        //s3.run(); //报错，Object没有run方法</span><br><span class="line"></span><br><span class="line">        s1.eat();</span><br><span class="line">        //s2.eat(); //报错，因为父(Person)没有子(Student)的方法(eat)所以不能调，可以先强转为Student再调用</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 所以，左边定义的类里有什么方法就只能调这些方法（自己的或继承的）</span><br><span class="line">         * 如果这些方法已被子类重写那调用就是重写后的方法</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p><code>X instanceof Y</code>，Y 必须是 引用X所指向的实例 的父类/同类才为真</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Person.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line">public class Person &#123; public void run()&#123; System.out.println(&quot;Person.run&quot;); &#125; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Student.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line">public class Student extends Person &#123; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Teacher.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line">public class Teacher extends Person &#123; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Application.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object o = new Student();</span><br><span class="line">        System.out.println(o instanceof Student); //true</span><br><span class="line">        System.out.println(o instanceof Person); //true</span><br><span class="line">        System.out.println(o instanceof Object); //true</span><br><span class="line">        System.out.println(o instanceof Teacher); //false</span><br><span class="line">        System.out.println(o instanceof String); //false</span><br><span class="line">        System.out.println(&quot;=====&quot;);</span><br><span class="line">        Person p = new Student();</span><br><span class="line">        System.out.println(p instanceof Student); //true(说Person是Student不成立，但引用p指向的实例是Student)</span><br><span class="line">        System.out.println(p instanceof Person); //true</span><br><span class="line">        System.out.println(p instanceof Object); //true</span><br><span class="line">        System.out.println(p instanceof Teacher); //false</span><br><span class="line">        //System.out.println(p instanceof String); //编译报错</span><br><span class="line">        System.out.println(&quot;=====&quot;);</span><br><span class="line">        Student s = new Student();</span><br><span class="line">        System.out.println(s instanceof Student); //true</span><br><span class="line">        System.out.println(s instanceof Person); //true</span><br><span class="line">        System.out.println(s instanceof Object); //true</span><br><span class="line">        //System.out.println(s instanceof Teacher); //编译报错</span><br><span class="line">        //System.out.println(s instanceof String); //编译报错</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类的转换"><a href="#类的转换" class="headerlink" title="类的转换"></a>类的转换</h1><ul>
<li>1.类的转换是发生在栈上，也就是转换引用而已</li>
<li>2.把子类‘直接’转为父类，父类的引用(栈)指向子类的对象(堆)，但是会丢失子类的方法</li>
<li>3.把父类‘强制’转为子类，子类的引用(栈)指向父类的对象(堆)，编译报错或运行报错，因为子类引用(栈)里有些方法在父类对象(堆)内找不到</li>
<li>4.类的转换方便方法的调用，减少重复的代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Person.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line">public class Person &#123; public void run()&#123; System.out.println(&quot;Person.run&quot;); &#125; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Student.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line">public class Student extends Person &#123; public void go()&#123; System.out.println(&quot;Student.go&quot;); &#125; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* Filename: Application.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p = new Person();</span><br><span class="line">        //Student conversion2s1 = p; //编译报错，因为堆内的对象为Person(父)，不能用栈内Student(子)引用去指向它，需要强转</span><br><span class="line">        //Student conversion2s2 = (Student) p; //编译通过但运行报错，原因同上</span><br><span class="line"></span><br><span class="line">        Student s = new Student();</span><br><span class="line">        Person conversion2p = s; //子类转父类</span><br><span class="line">        //conversion2p.go(); //编译报错，因为栈内引用Person没有go方法，也就是丢失了Student(子)的方法go</span><br><span class="line">        Student reset2s = (Student)conversion2p;</span><br><span class="line">        reset2s.go(); //打印Student.go，证明转为父类会丢失子类方法go，再转回子类又恢复了方法go</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Student.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line">    private static int age;</span><br><span class="line">    private double score;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student s1 = new Student();</span><br><span class="line"></span><br><span class="line">        Student.age = 10; //类成员</span><br><span class="line">        s1.age = 20; //此处访问的也是类成员</span><br><span class="line">        System.out.println(s1.age); //20</span><br><span class="line">        System.out.println(Student.age); //20</span><br><span class="line"></span><br><span class="line">        //Student.score = 10; //编译报错，类被加载时不会分配非staitc的属性，非static属性是属于对象的</span><br><span class="line">        s1.score = 20;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Student.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line">public class Student &#123;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        go(); //对象方法内可以调用类的方法</span><br><span class="line">    &#125;</span><br><span class="line">    public static void go()&#123;</span><br><span class="line">        //run(); //编译报错:类的方法内不可以调用对象的方法</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //run(); //编译报错:类的方法内不可以调用对象的方法</span><br><span class="line">        go(); //类可以直接调用类自己的方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="static代码块"><a href="#static代码块" class="headerlink" title="static代码块"></a>static代码块</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Person.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    &#123; //2 :可以在里面赋初值</span><br><span class="line">        System.out.println(&quot;匿名代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static&#123; //1 静态代码块只执行/初始化一次</span><br><span class="line">        System.out.println(&quot;静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person() &#123; //3</span><br><span class="line">        System.out.println(&quot;构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p1 = new Person();</span><br><span class="line">        System.out.println(&quot;====&quot;);</span><br><span class="line">        Person p2 = new Person();</span><br><span class="line">        /**运行输出</span><br><span class="line">         * 静态代码块</span><br><span class="line">         * 匿名代码块</span><br><span class="line">         * 构造方法</span><br><span class="line">         * ====</span><br><span class="line">         * 匿名代码块</span><br><span class="line">         * 构造方法</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="外部package的函数导入"><a href="#外部package的函数导入" class="headerlink" title="外部package的函数导入"></a>外部package的函数导入</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Test.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line">import static java.lang.Math.random;</span><br><span class="line">import static java.lang.Math.PI;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Math.random()); //用package去调用random</span><br><span class="line">        System.out.println(random()); //也可以先import static java.lang.Math.random之后就可以直接调用</span><br><span class="line">        System.out.println(PI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h1><p>用<code>final</code>修饰的类是没有子类的。</p>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><ul>
<li><code>abstract</code>修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么就是抽象方法；修饰类那就是抽象类</li>
<li>抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。</li>
<li>抽象类不能用<code>new</code>关键字来创建对象，它是用来让子类继承的。</li>
<li>抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的。</li>
<li>子类继承抽象类，那么就必须要实现抽象类里没有实现的抽象方法，否则该子类也要声明为抽象类。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Action.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line"></span><br><span class="line">//抽象(abstract)类，不能被new出来，只能被继承</span><br><span class="line">public abstract class Action &#123;</span><br><span class="line">    //抽象(abstract)方法如果：</span><br><span class="line">    // 被&quot;abstract修饰的子类&quot;继承可以不写方法体；</span><br><span class="line">    // 被&quot;非abstract修饰的子类&quot;继承需要写方法体。</span><br><span class="line">    public abstract void doSomething(); //抽象方法目的在于约束子类必须实现</span><br><span class="line">    public void go()&#123; System.out.println(&quot;Action.go&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:A.java */</span><br><span class="line">package com.oop.demo;</span><br><span class="line">public abstract class A extends Action &#123;</span><br><span class="line">    //因为doSomething()是抽象方法，所以子类(A)必须重写/实现出来，如果子类(A)是抽象类则不用重写/实现</span><br><span class="line">    //@Override</span><br><span class="line">    //public void doSomething() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    //Action.go()不是抽象方法，所以子类(A)可以重写/实现，也可以不重写/实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>javaTips:类是单继承，接口可以多继承</p>
<p>思考题：1.抽象类不能<code>new</code>,那它有构造器吗？2.抽象类存在意义是什么？（游戏角色抽象出来，让子类继承去实现。提高开发效率，可扩展性高）</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul>
<li><p>普通类：只有具体实现</p>
</li>
<li><p>抽象类：具体实现和规范（抽象方法）都有</p>
</li>
<li><p>接口：只有规范（使得约束和实现分离，项目组长约定好接口，员工面向接口编程）</p>
</li>
<li><p>接口就是规范，定义是一组规则，体现了现实世界中“如果你是…则必须能…”的意思。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。</p>
</li>
<li><p>接口本质是契约，就像我们人间的法律一样。制定好后大家都遵守。</p>
</li>
<li><p>OO的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言（如C+++,java,C#等），就是因为设计模式所研究的，实际上就是如何合理去抽象。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:UserService.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line">public interface UserService &#123;</span><br><span class="line">    //接口内的方法默认是public abstract，可省略不写</span><br><span class="line">    ///*public abstract*/ void run(String name);</span><br><span class="line">    void add(String name);</span><br><span class="line">    void delete(String name);</span><br><span class="line">    void update(String name);</span><br><span class="line">    void query(String name);</span><br><span class="line"></span><br><span class="line">    //接口内的属性默认是常量 public static final（一般不这样定义使用）</span><br><span class="line">    /*public static final*/ int AGE=99;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:TimeService.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line">public interface TimeService &#123; void timer(); &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:UserServiceImp.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">//接口都需要有实现类，它不能直接被实例化，因为没构造方法</span><br><span class="line">//如果类 implements 了接口，则必须重写里面所有的方法</span><br><span class="line">//类是多继承(extends)的，接口是多实现(implements)的，或者说，类可以集成实现多个接口(interface)</span><br><span class="line">public class UserServiceImp implements UserService,TimeService&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void add(String name) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void delete(String name) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(String name) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void query(String name) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void timer() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>内部类就是在一个类内部再定义一个类。比如A类中定义一个B类，那么B类相对A类来说就称为内部类，而A类相对B类来说就是外部类了。</p>
<ul>
<li>1.成员内部类</li>
<li>2.静态内部类</li>
<li>3.局部内部类</li>
<li>4.匿名内部类</li>
</ul>
<h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Outer.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line">public class Outer &#123;</span><br><span class="line">    private int id = 10;</span><br><span class="line">    public void out()&#123; System.out.println(&quot;这是外部方法&quot;); &#125;</span><br><span class="line"></span><br><span class="line">    public class Inner &#123; //成员内部类</span><br><span class="line">        public void in()&#123; System.out.println(&quot;这是内部方法&quot;); &#125;</span><br><span class="line"></span><br><span class="line">        //直接访问外部类的私有属性</span><br><span class="line">        public void getID()&#123; System.out.println(&quot;id = &quot; + id); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Application.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer outer = new Outer();</span><br><span class="line">        //通过外部类的&#x27;实例&#x27;去new 内部类</span><br><span class="line">        Outer.Inner inner = outer.new Inner();</span><br><span class="line">        inner.in(); //这是内部方法</span><br><span class="line">        inner.getID(); //id = 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Outer.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line">public class Outer &#123;</span><br><span class="line">    private int id = 10;</span><br><span class="line">    public void out()&#123; System.out.println(&quot;这是外部方法&quot;); &#125;</span><br><span class="line"></span><br><span class="line">    public static class Inner &#123; //静态内部类</span><br><span class="line">        public void in()&#123; System.out.println(&quot;这是内部方法&quot;); &#125;</span><br><span class="line"></span><br><span class="line">        //编译报错：Inner在静态区，id属性不在静态区，除非用static修饰id，否则必须实例化才能访问id</span><br><span class="line">        //public void getID()&#123; System.out.println(&quot;id = &quot; + id); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Application.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer outer = new Outer();</span><br><span class="line">        //直接new 外部类里的内部类</span><br><span class="line">        Outer.Inner inner = new Outer.Inner();</span><br><span class="line">        inner.in(); //这是内部方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:outer.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">public class Outer &#123; &#125;</span><br><span class="line"></span><br><span class="line">//一个java文件中可以有多个class，但只有一个public class</span><br><span class="line">class A&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;A.main&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:outer.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">public class Outer &#123;</span><br><span class="line">    public void method()&#123;</span><br><span class="line">        //局部内部类</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            public void in()&#123;</span><br><span class="line">                System.out.println(&quot;Inner.in&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Test.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //不需要变量保存实例，没有名字初始化类（匿名）</span><br><span class="line">        new Apple().eat(); //Apple.eat</span><br><span class="line"></span><br><span class="line">        //也是匿名类</span><br><span class="line">        UserService userService = new UserService() &#123;</span><br><span class="line">            @Override //运行的时候才重写/实现接口的方法，也就等于定义了新的类，并且用new实例化了，保存在userService中</span><br><span class="line">            public void hello() &#123;</span><br><span class="line">                System.out.println(&quot;Test.hello&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        userService.hello();//Test.hello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Apple &#123;</span><br><span class="line">    public void eat()&#123; System.out.println(&quot;Apple.eat&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface UserService&#123;</span><br><span class="line">    void hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ul>
<li>运行过程中出现状况：用户输入不合法；打开一个文件可是文件不存在或格式不合法；读数据库却是空的；内存耗光或硬盘满了……</li>
<li>软件程序在运行过程中，非常可能遇到刚刚提到的这些问题，叫做异常(<code>Exception</code>)，翻译是例外，可以理解为例外的情况就是异常情况。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Application.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(11/0); //Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3种类型的异常：</p>
<ul>
<li>1.检查性异常，最具代表的检查性异常是用户错误输入引起的异常，这是开发者无法预见的。如：打开一个不存在的文件就会引发异常。这个异常在编译时不能被简单地忽略。</li>
<li>2.运行时异常，最容易被避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>
<li>3.错误，错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如：当栈溢出的错误没办法在编译时就检查到。</li>
</ul>
<p>Java把异常当作对象处理，并定义一个基类<code>java.lang.Throwable</code>作为所有异常的超类。在Java API中已经定义了许多异常类，这些异常类分为两大类，错误<code>Error</code>和异常<code>Exception</code></p>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><ul>
<li><code>Error</code>类对象由Java虚拟机生成并抛出，大多数错误跟代码编写者所写的无关。</li>
<li>Java虚拟机运行错误(Virtual MachineError)，当JVM不再有继续执行操作所需的内存资源时，将出现<code>OutOfMemoryError</code>。这些异常发生时，Java虚拟机(JVM)一般会选择线程终止。</li>
<li>还有发生在虚拟机试图执行应用时，如类定义错误(<code>NoClassDefFoundError</code>)、链接错误(<code>LinkageError</code>)。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且大多数是程序运行时不允许出现这样的情况。</li>
</ul>
<h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p>在<code>Exception</code>分支中有一个重要的自类<code>RuntimeException</code>（运行时异常）</p>
<ul>
<li><code>ArrayIndexOutOfBoundsException</code>(数组下标越界)</li>
<li><code>NullPointerException</code>(空指针异常)</li>
<li><code>ArithmeticException</code>(算术异常)</li>
<li><code>MissingResourceException</code>(丢失资源)</li>
<li><code>ClassNotFoundException</code>(找不到类)</li>
<li>…<br>这些是不检查异常，程序中可以选择捕获处理，也可不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</li>
</ul>
<p><code>Error</code>和<code>Exception</code>的区别：</p>
<ul>
<li><code>Error</code>通常是灾难性、致命性的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机(JVM)一般会选择终止线程。</li>
<li><code>Exception</code>通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常</li>
</ul>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Test.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 1;</span><br><span class="line">        int b = 0;</span><br><span class="line"></span><br><span class="line">        //try catch 需要有，finally可以没有。finally一般是需要在异常后关闭IO、释放资源的情况写</span><br><span class="line">        try&#123; //try监控区域</span><br><span class="line">            System.out.println(a / b);</span><br><span class="line">        &#125;catch (ArithmeticException e)&#123; //catch 捕获到异常后的处理区</span><br><span class="line">            System.out.println(&quot;捕获异常，除数不能为0&quot;);</span><br><span class="line">        &#125;finally &#123; //处理善后区，不管有无捕获异常都会处理，</span><br><span class="line">            System.out.println(&quot;finally&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>捕获多个异常需要从小到大</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Test.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 1;</span><br><span class="line">        int b = 0;</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.println(a / b);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Error e)&#123;</span><br><span class="line">            System.out.println(&quot;Error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)&#123;</span><br><span class="line">            System.out.println(&quot;Exception&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable e)&#123;</span><br><span class="line">            System.out.println(&quot;Throwable&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            System.out.println(&quot;finally&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IDEAtips:选中代码，按<code>Ctrl+Alt+t</code>可弹出补全逻辑</p>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Test2.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">public class Test2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            new Test2().test(1,0);</span><br><span class="line">        &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //注意 throw 和 throws 两关键字</span><br><span class="line">    public void test(int a, int b) throws ArithmeticException&#123;</span><br><span class="line">        if (b == 0) &#123;</span><br><span class="line">            throw new ArithmeticException(); //throw 一般是在方法内处理不了，于是主动往更高级抛出异常</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(a / b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常（只需继承<code>Exception</code>类即可）</p>
<p>自定义异常类步骤：</p>
<ul>
<li>1.创建自定义异常类</li>
<li>2.在方法中通过<code>throw</code>关键字抛出异常对象</li>
<li>3.如果在当前抛出异常的方法中处理异常，则可使用<code>try-catch</code>语句捕获并处理；否则在方法的声明处通过<code>throws</code>关键字指明要抛出给方法调用者的异常，继续进行下一步操作</li>
<li>4.在出现异常方法的调用者中捕获并处理异常</li>
</ul>
<p>IDEAtips:双击<code>Shift</code>可弹出搜索框</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:MyException.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">//自定义异常类</span><br><span class="line">public class MyException extends Exception&#123;</span><br><span class="line">    //传递数字&gt;10</span><br><span class="line">    private int detail;</span><br><span class="line"></span><br><span class="line">    public MyException(int detail) &#123;</span><br><span class="line">        this.detail = detail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //toString:异常打印信息</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyException&#123;&quot; + &quot;detail=&quot; + detail + &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* Filename:Test.java */</span><br><span class="line">package com.humble.oop;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    static void test(int a) throws MyException &#123;</span><br><span class="line">        System.out.println(&quot;a = &quot; + a);</span><br><span class="line">        if (a &gt; 10)&#123;</span><br><span class="line">            throw new MyException(a);//抛出</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Test.test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            test(11);</span><br><span class="line">        &#125; catch (MyException e) &#123;</span><br><span class="line">            System.out.println(&quot;e = &quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 运行输出</span><br><span class="line"> * a = 11</span><br><span class="line"> * e = MyException&#123;detail=11&#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<ul>
<li>处理运行时异常时，采用逻辑去合理规避同时辅助<code>try-catch</code>处理</li>
<li>在多重catch块后面，可以加一个<code>catch(Exception)</code>来处理可能会被遗漏的异常</li>
<li>对于不确定的代码，可以加上<code>try-catch</code>，处理潜在的异常</li>
<li>尽量去处理异常，切忌只是简单地调用<code>printStackTrace()</code>去打印输出</li>
<li>具体如何处理异常，要根据不同的业务需求和异常类型去决定</li>
<li>尽量添加<code>finally</code>语句块去释放占用的资源</li>
</ul>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2020/12/09/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/">C语言语法笔记</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://humble-zh.github.io/page/5/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2020-12-09T03:40:37.000Z" itemprop="datePublished">2020-12-09</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/C-C/" rel="tag">C/C++</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="打印限定长度字符串"><a href="#打印限定长度字符串" class="headerlink" title="打印限定长度字符串"></a><a target="_blank" rel="noopener" href="https://rayed.com/posts/2016/02/limit-string-length-in-printf-in-c/">打印限定长度字符串</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *s = <span class="string">&quot;This my world.&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, %.5s!\n&quot;</span>, s+<span class="number">8</span>); <span class="built_in">printf</span>(<span class="string">&quot;Hello, %.*s!\n&quot;</span>, <span class="number">5</span>, s+<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> minlen=<span class="number">5</span>,maxlen=<span class="number">5</span>; <span class="built_in">printf</span>(<span class="string">&quot;Hello, %*.*s\n&quot;</span>, minlen, maxlen, s+<span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<h2 id="打印后回填长度至参数’-n’"><a href="#打印后回填长度至参数’-n’" class="headerlink" title="打印后回填长度至参数’%n’"></a><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/c-program-to-print-the-length-of-a-string-using-n-format-specifier/">打印后回填长度至参数’%n’</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">&quot;world!&quot;</span>; <span class="keyword">int</span> len = <span class="number">0</span>; <span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n%n&quot;</span>, str, &amp;len); <span class="built_in">printf</span>(<span class="string">&quot; = %d\n&quot;</span>, len); <span class="comment">// = 13</span></span><br></pre></td></tr></table></figure>
<h2 id="打印double格式’-f’"><a href="#打印double格式’-f’" class="headerlink" title="打印double格式’%f’"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4264127/correct-format-specifier-for-double-in-printf">打印double格式’%f’</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">1.4</span>; <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, f);  <span class="comment">//正确,f会被提升到double再用%f打印</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">1.4</span>; <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, d); <span class="comment">//正确,若指定&quot;%lf&quot;,则l无意义</span></span><br></pre></td></tr></table></figure>
<h2 id="implicit-declaration-of-function-‘strdup’"><a href="#implicit-declaration-of-function-‘strdup’" class="headerlink" title="implicit declaration of function ‘strdup’"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/26284110/strdup-confused-about-warnings-implicit-declaration-makes-pointer-with">implicit declaration of function ‘strdup’</a></h2><p>在<code>#include &lt;string.h&gt;</code>前面添加下面的其中任一宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE &gt;= <span class="number">500</span></span><br><span class="line">    || _XOPEN_SOURCE &amp;&amp; _XOPEN_SOURCE_EXTENDED</span><br><span class="line">    || <span class="comment">/* Since glibc 2.12: */</span> _POSIX_C_SOURCE &gt;= <span class="number">200809L</span></span><br></pre></td></tr></table></figure>
<p>或者在gcc编译选项内加上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-D_SVID_SOURCE</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-D_POSIX_C_SOURCE=<span class="number">200809L</span></span><br></pre></td></tr></table></figure>
<h2 id="编译链接动态库找不到libtcmalloc-minimal"><a href="#编译链接动态库找不到libtcmalloc-minimal" class="headerlink" title="编译链接动态库找不到libtcmalloc_minimal"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/8048165/linking-with-libtcmalloc-ubuntu">编译链接动态库找不到libtcmalloc_minimal</a></h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dpkg -L libtcmalloc-minimal0</span><br><span class="line">/.</span><br><span class="line">/usr</span><br><span class="line">/usr/lib</span><br><span class="line">/usr/lib/libtcmalloc_minimal.so.0.0.0</span><br><span class="line">/usr/lib/libtcmalloc_minimal_debug.so.0.0.0</span><br><span class="line">/usr/share</span><br><span class="line">/usr/share/doc</span><br><span class="line">/usr/share/doc/libtcmalloc-minimal0</span><br><span class="line">/usr/share/doc/libtcmalloc-minimal0/TODO</span><br><span class="line">/usr/share/doc/libtcmalloc-minimal0/AUTHORS</span><br><span class="line">/usr/share/doc/libtcmalloc-minimal0/copyright</span><br><span class="line">/usr/share/doc/libtcmalloc-minimal0/changelog.gz</span><br><span class="line">/usr/share/doc/libtcmalloc-minimal0/README.gz</span><br><span class="line">/usr/share/doc/libtcmalloc-minimal0/changelog.Debian.gz</span><br><span class="line">/usr/lib/libtcmalloc_minimal.so.0</span><br><span class="line">/usr/lib/libtcmalloc_minimal_debug.so.0</span><br></pre></td></tr></table></figure>
<p>编译使用<code>-lxxx</code>默认会去环境变量对应库目录找<code>xxx.so</code>后缀的库文件，找不到<code>libtcmalloc_minimal.so</code>所以编译失败。下面有4个解决方法:</p>
<ol>
<li>安装<code>libtcmalloc_minimal0-dev</code>之后就会有<code>libtcmalloc_minimal.so</code>文件</li>
<li>进入库目录，手动生成符号链接文件<code>ln -s libtcmalloc_minimal.so.0.0.0 libtcmalloc_minimal.so</code></li>
<li>编译时指定真实文件绝对路径<code>gcc test /usr/lib/libtcmalloc_minimal.so.0.0.0</code></li>
<li>编译时用<code>-l</code>指定文件全名<code>-l:libtcmalloc_minimal.so.0.0.0</code></li>
</ol>
<h2 id="ctime使用"><a href="#ctime使用" class="headerlink" title="ctime使用"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/singleyellow/article/details/67638310">ctime使用</a></h2><p><code>printf(&quot;%s&quot;, ctime(&amp;time(NULL)));</code> 本来以为可以省掉一个中间变量timer，而且显得高大上。编译时给出错误： 单目‘&amp;’的操作数必须是左值，这段代码想直接对<code>time()</code>的返回值取地址，这是绝对不正确的，因为函数返回值是匿名变量，只能当右值，不可以做左值</p>
<h2 id="打印带颜色和属性的字体"><a href="#打印带颜色和属性的字体" class="headerlink" title="打印带颜色和属性的字体"></a>打印带颜色和属性的字体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foreground colours</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[30m black \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[31m red \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[32m green \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[33m yellow \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[34m blue \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[35m magenta \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[36m cyan \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[37m white \033[m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// background colours</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[40m black \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[41m red \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[42m green \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[43m yellow \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[44m blue \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[45m magenta \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[46m cyan \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[47m white \033[m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// other</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[0m default \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[1m bold \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[2m faint \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[3m italic \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[4m underlined \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[5m slowblink \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[6m rapidblink \033[m\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[7m negative \033[m\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="查看内存泄露"><a href="#查看内存泄露" class="headerlink" title="查看内存泄露"></a>查看内存泄露</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/`pidof hello`/status |grep <span class="string">&#x27;VmData:&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="make传参"><a href="#make传参" class="headerlink" title="make传参"></a>make传参</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make CFLAGS=-m32 LDFLAGS=-m32  <span class="comment"># 编译链接32位</span></span><br></pre></td></tr></table></figure>
<h2 id="64位系统编译32位libpcap"><a href="#64位系统编译32位libpcap" class="headerlink" title="64位系统编译32位libpcap"></a>64位系统编译32位libpcap</h2><ul>
<li>报错<code>/usr/bin/ld: 当搜索用于 /usr/lib/libnl-3.so 时跳过不兼容的 -lnl-3</code>就安装<code>lib32-libnl</code></li>
<li>报错<code>/usr/bin/ld: 找不到 -ldbus-1: 没有那个文件或目录</code>就安装<code>lib32-dbus</code></li>
</ul>
<h2 id="交叉编译术语"><a href="#交叉编译术语" class="headerlink" title="交叉编译术语"></a>交叉编译术语</h2><h3 id="3种机器"><a href="#3种机器" class="headerlink" title="3种机器"></a>3种机器</h3><ul>
<li>Build machine: where the toolchain is built(用来构建gcc工具链的机器)</li>
<li>Host machine: where the toolchain will be executed(运行gcc工具链的机器)</li>
<li>Target machine: where the binaries created by the toolchain are executed(gcc工具链创建的二进制文件运行时所在的机器)</li>
</ul>
<h3 id="4种构建方式"><a href="#4种构建方式" class="headerlink" title="4种构建方式"></a>4种构建方式</h3><ul>
<li>Native build:BUILD==HOST==TARGET(三个都是x86)本机构建</li>
<li>Cross-build:BUILD==HOST!=TARGET(交叉构建BUILD==HOST==x86 TARGET==arm)在x86上编译出gcc工具链，在x86上使用该gcc编译出arm的程序</li>
<li>Cross-native build:BUILD!=HOST==TARGET(跨本机构建BUILD==x86 HOST==TARGET==arm)在x86编译出gcc工具链，把gcc工具链拷贝到arm，在arm用gcc编译出arm的程序</li>
<li>Canadian toolchain:BUILD!=HOST!=TARGET(加拿大工具链BUILD==x86 HOST==mac TARGET==arm)在x86上编译出gcc工具链，拷贝到mac，在mac上使用该gcc编译出arm的程序</li>
</ul>
<h3 id="configure参数"><a href="#configure参数" class="headerlink" title="configure参数"></a>configure参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--build=BUILD           configure <span class="keyword">for</span> building on BUILD [BUILD=HOST]</span><br><span class="line">--host=HOST             configure <span class="keyword">for</span> HOST [guessed]</span><br><span class="line">--target=TARGET         configure <span class="keyword">for</span> TARGET [TARGET=HOST]</span><br></pre></td></tr></table></figure>
<p>如你在使用<code>arm-none-linux-gnueabi-gcc</code>，可设置<code>--host=arm-none-linux-gnueabi --target=arm-none-linux-gnueabi</code>，而<code>--build</code>会自动被设置</p>
<p>指定编译器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure CC=/tmp/arm/arm-linux-gcc CXX=/tmp/arm/arm-linux-g++</span><br></pre></td></tr></table></figure>
<p>修改环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> C_INCLUDE_PATH=<span class="variable">$&#123;HOME&#125;</span>/path/to/include:<span class="variable">$C_INCLUDE_PATH</span></span><br><span class="line"><span class="built_in">export</span> CPLUS_INCLUDE_PATH=<span class="variable">$&#123;HOME&#125;</span>/path/to/include:<span class="variable">$CPLUS_INCLUDE_PATH</span></span><br><span class="line"><span class="built_in">export</span> LIBRARY_PATH=<span class="variable">$&#123;HOME&#125;</span>/path/to/lib:<span class="variable">$LIBRARY_PATH</span> <span class="comment">#编译时在这些路径下进行查找库</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$&#123;HOME&#125;</span>/path/to/lib:<span class="variable">$LD_LIBRARY_PATH</span> <span class="comment">#运行时在这些路径下查找库</span></span><br></pre></td></tr></table></figure>
<h3 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h3><p>在第一个参数位置指定目标架构，<code>-–cross-compile-prefix</code>指定了命令前缀</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./Configure linux-aarch64 --cross-compile-prefix=aarch64-himix100-linux- --prefix=/tmp/result &amp;&amp; make &amp;&amp; make install</span><br><span class="line"><span class="comment">#./Configure linux-armv4 --cross-compile-prefix=arm-himix200-linux- --prefix=/tmp/result &amp;&amp; make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure>
<p>若报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crypto/aes/aes-x86_64.s: Assembler messages:</span><br><span class="line">crypto/aes/aes-x86_64.s:2: Error: unrecognized symbol <span class="built_in">type</span> <span class="string">&quot;&quot;</span></span><br><span class="line">crypto/aes/aes-x86_64.s:3: Error: alignment too large: 15 assumed</span><br><span class="line">crypto/aes/aes-x86_64.s:5: Error: bad instruction `xorl 0(%r15),%eax<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<p>从错误打印看到，错误出现在编译 .s 文件(汇编文件)时，且后面还打印了汇编代码。原来 <code>openssl</code> 在编译时会默认使用汇编代码来加速编译过程，但只针对 <code>x86</code>平台，而 <code>x86</code>平台 的汇编代码和 <code>arm</code>平台 的汇编代码是不同的，所以会报错。加<code>no-asm</code>解决，表示不使用汇编代码加速编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Configure linux-aarch64 no-asm --cross-compile-prefix=aarch64-himix100-linux- --prefix=/tmp/result &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>若报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc1: error: unrecognized <span class="built_in">command</span> line option <span class="string">&quot;-m64&quot;</span></span><br></pre></td></tr></table></figure>
<p>删除<code>Makefile</code>的<code>-m64</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&quot;s/ -m64//g&quot;</span> Makefile</span><br></pre></td></tr></table></figure>
<h3 id="在64位机器编译32位的openssl"><a href="#在64位机器编译32位的openssl" class="headerlink" title="在64位机器编译32位的openssl"></a>在64位机器编译32位的openssl</h3><p><code>setarch i386 ./config -m32</code>或<code>./Configure -m32 linux-generic32</code>或<code>./Configure linux-generic32 --shared</code></p>
<h3 id="编译参数"><a href="#编译参数" class="headerlink" title="编译参数"></a>编译参数</h3><p>-<code>CFLAGS</code>:C 编译器的选项，如指定头文件（.h文件）的路径，<code>CFLAGS=-I/usr/include -I/path/include</code><br>-<code>CXXFLAGS</code>:C++ 编译器的选项。<br>-<code>LDFLAGS</code>:编译器会用到的一些优化参数，也可以在里面指定库文件的位置。<code>LDFLAGS=-L/usr/lib -L/path/to/your/lib</code>。<br>-<code>LIBS</code>：告诉链接器要链接哪些库文件，如<code>LIBS = -lpthread -liconv</code>，<code>LDFLAGS</code>告诉链接器库文件在哪个目录，<code>LIBS</code>是告诉链接器要链接哪些库文件</p>
<p>运行时找不到库，就需要在编译时给<code>LDFLAGS</code>增加<code>-Wl,R</code>，<code>LDFLAGS = -L/var/xxx/lib -L/opt/mysql/lib -Wl,R/var/xxx/lib -Wl,R/opt/mysql/lib</code></p>
<p>如果在<code>./configure</code>前就设置了环境变量<code>export LDFLAGS=&quot;-L/var/xxx/lib -L/opt/mysql/lib -Wl,R/var/xxx/lib -Wl,R/opt/mysql/lib&quot;</code> ，那么在<code>./configure</code>后，<code>Makefile</code>将会设置<code>LDFLAGS</code>这个选项，链 接时会有这个参数，编译出来的可执行程序的库文件搜索路径就得到扩展了。</p>
<h3 id="ldd查看程序运行缺的依赖库"><a href="#ldd查看程序运行缺的依赖库" class="headerlink" title="ldd查看程序运行缺的依赖库"></a>ldd查看程序运行缺的依赖库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ldd hello</span><br><span class="line">    ...</span><br><span class="line">    libzlog.so.1 =&gt; not found</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h3 id="readelf查看库的soname"><a href="#readelf查看库的soname" class="headerlink" title="readelf查看库的soname"></a>readelf查看库的soname</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -d /usr/lib/libzlog.so.1.2</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x18db8 contains 25 entries:</span><br><span class="line">  标记        类型                         名称/值</span><br><span class="line"> 0x0000000000000001 (NEEDED)             共享库：[libc.so.6]</span><br><span class="line"> 0x000000000000000e (SONAME)             Library soname: [libzlog.so.1]</span><br><span class="line"> 0x000000000000000c (INIT)               0x4000</span><br><span class="line"> 0x000000000000000d (FINI)               0x12884</span><br><span class="line"> 0x0000000000000019 (INIT_ARRAY)         0x19da8</span><br><span class="line"> 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000000000001a (FINI_ARRAY)         0x19db0</span><br><span class="line"> 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000006ffffef5 (GNU_HASH)           0x300</span><br><span class="line"> 0x0000000000000005 (STRTAB)             0x18f0</span><br><span class="line"> 0x0000000000000006 (SYMTAB)             0x6f0</span><br><span class="line"> 0x000000000000000a (STRSZ)              2977 (bytes)</span><br><span class="line"> 0x000000000000000b (SYMENT)             24 (bytes)</span><br><span class="line"> 0x0000000000000003 (PLTGOT)             0x1a000</span><br><span class="line"> 0x0000000000000002 (PLTRELSZ)           3672 (bytes)</span><br><span class="line"> 0x0000000000000014 (PLTREL)             RELA</span><br><span class="line"> 0x0000000000000017 (JMPREL)             0x2858</span><br><span class="line"> 0x0000000000000007 (RELA)               0x26a8</span><br><span class="line"> 0x0000000000000008 (RELASZ)             432 (bytes)</span><br><span class="line"> 0x0000000000000009 (RELAENT)            24 (bytes)</span><br><span class="line"> 0x000000006ffffffe (VERNEED)            0x2618</span><br><span class="line"> 0x000000006fffffff (VERNEEDNUM)         1</span><br><span class="line"> 0x000000006ffffff0 (VERSYM)             0x2492</span><br><span class="line"> 0x000000006ffffff9 (RELACOUNT)          3</span><br><span class="line"> 0x0000000000000000 (NULL)               0x0</span><br></pre></td></tr></table></figure>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2020/09/03/apue%E9%AB%98%E7%BA%A7IO/">apue高级IO</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://humble-zh.github.io/page/5/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2020-09-03T10:53:15.000Z" itemprop="datePublished">2020-09-03</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/apue/" rel="tag">apue</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="apue高级IO"><a href="#apue高级IO" class="headerlink" title="apue高级IO"></a>apue高级IO</h1><h2 id="非阻塞-I-O"><a href="#非阻塞-I-O" class="headerlink" title="非阻塞 I/O"></a>非阻塞 I/O</h2><p>之前讨论的所有函数都是阻塞的，如<code>read(2)</code>函数读取设备时，设备中如果没有充足的数据，那么<code>read(2)</code>函数就会阻塞等待，直到有数据可读再返回。当 IO 操作时出错时，需要判断是真的出错还是假错。</p>
<p>两种假错的情况：</p>
<ul>
<li>EINTR：被信号打断，阻塞时会遇到。</li>
<li>EAGAIN：非阻塞形式操作失败。</li>
</ul>
<p>遇到这两种假错的时候我们需要重新再操作一次(占用CPU)，所以通常对假错的判断是放在循环中的。例如<code>read(2)</code>函数使用非阻塞方式读取数据时，如果没有读取到数据，<code>errno</code>为<code>EAGAIN</code>，表明是非阻塞方式读取返回了，并非设备有问题或读取失败。</p>
<p>阻塞与非阻塞是使用的同一套函数，<code>flags</code>特殊要求指定为<code>O_NONBLOCK</code>就可以了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/etc/service&quot;</span>, O_RDONLY | O_NONBLOCK); <span class="comment">//以非阻塞方式打开</span></span><br><span class="line"><span class="comment">/* if error */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    size = read(fd, buf, BUFSIZE);</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (EAGAIN == errno) &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">//发生假错，重复read</span></span><br><span class="line">        &#125;</span><br><span class="line">        perror(<span class="string">&quot;read()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do sth...</span></span><br></pre></td></tr></table></figure>
<h2 id="IO多路转接"><a href="#IO多路转接" class="headerlink" title="IO多路转接"></a>IO多路转接</h2><p>IO密集型的任务，可以使用IO多路转接。<code>select()</code>,<code>poll()</code>,<code>epoll()</code></p>
<p>先布置监视任务（设置自己关心/感兴趣的事件/文件描述符），监视多个IO(文件描述符)，当某个文件描述符发生了我们感兴趣的事情(读/写)的时候再去操作(读/写)。</p>
<p><code>select(2)</code>移植性高，各个平台都支持它，这也是它相对于<code>poll(2)</code>唯一的优点。</p>
<p><code>select(2)</code>关心的是事件，<code>poll()</code>关心的是文件描述符。</p>
<p><code>select(2)</code>和<code>poll()</code>都是可移植的，<code>epoll()</code>是Linux平台实现的方言。<code>epoll()</code>是利用<code>poll()</code>封装的。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IO多路转接(IO复用)</span></span><br><span class="line"><span class="comment">//fd_set 文件描述符集合</span></span><br><span class="line"><span class="comment">//nfds:你所监视fd_set中最大的那个再加1(如:监视1,4,那nfds取5,因为内核用的是&lt;nfds,不加1就无法监视最大那个)</span></span><br><span class="line"><span class="comment">//readfds:你关心哪些文件描述符的可读事件</span></span><br><span class="line"><span class="comment">//writefds:你关心哪些文件描述符的可写事件</span></span><br><span class="line"><span class="comment">//exceptfds:你关心哪些文件描述符的异常事件</span></span><br><span class="line"><span class="comment">//timeout:阻塞的超时时间，如果不设置则阻塞等到关心事件发生才返回</span></span><br><span class="line"><span class="comment">//返回：</span></span><br><span class="line"><span class="comment">//  表示有多少个文件描述符发生了你关心的事件，发生的事件回填到了readfds,writefds,exceptfds里面(下次又得重新设置这3个再调用select)</span></span><br><span class="line"><span class="comment">//  出错返回-1，并设置errno(若设置了超时，超时过后返回-1，errno设为EINTR(假错))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">            fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">//从set中删除fd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">//判断fd是否在set中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">//把fd加入set中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">//把set清空</span></span><br></pre></td></tr></table></figure>
<p><code>select(2)</code>可相当于一个安全可靠的休眠。某些平台的<code>sleep()</code>用的是信号，不是很安全。</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/humble-zh/studyapue/blob/master/io/adv/select/relay.c">查看代码</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./io/adv/select/relay.c</span><br><span class="line"><span class="comment">#define use_select (1)</span></span><br></pre></td></tr></table></figure>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待某个事件在指定的文件描述符上发生</span></span><br><span class="line"><span class="comment">//fds:结构体数组</span></span><br><span class="line"><span class="comment">//nfds:结构体数组长度(有多少个文件描述符)</span></span><br><span class="line"><span class="comment">//timeout:超时设置(毫秒),0-非阻塞,-1-阻塞</span></span><br><span class="line"><span class="comment">//返回：</span></span><br><span class="line"><span class="comment">//  正数，有多少个事件发生了</span></span><br><span class="line"><span class="comment">//  0，没有发生事件，超时返回</span></span><br><span class="line"><span class="comment">//  -1，出错并设置errno(EINTR是假错)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd; <span class="comment">//file descriptor 文件描述符</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">// requested events 关心的事件</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">// returned events 发生的事件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关心的事件和发生的事件是分开的两个成员，所以关心的事件发生一次后不用重新设置。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个epoll文件描述符(创建数组)</span></span><br><span class="line"><span class="comment">//size:忽略(随便填个正数)</span></span><br><span class="line"><span class="comment">//返回：</span></span><br><span class="line"><span class="comment">//  正数，成功，表示有多少个文件描述符。</span></span><br><span class="line"><span class="comment">//  -1，出错并设置errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//控制epoll文件描述符</span></span><br><span class="line"><span class="comment">//对epfd实例用的fd进行op操作event</span></span><br><span class="line"><span class="comment">//epfd:用epoll_create创建的实例</span></span><br><span class="line"><span class="comment">//op:EPOLL_CTL_ADD,EPOLL_CTL_MOD,EPOLL_CTL_DEL</span></span><br><span class="line"><span class="comment">//fd:目标文件描述符</span></span><br><span class="line"><span class="comment">//event:目标的事件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>    *ptr;</span><br><span class="line">    <span class="keyword">int</span>	fd;  <span class="comment">//目标文件描述符</span></span><br><span class="line">    <span class="keyword">uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> events; <span class="comment">// Epoll events 关心的事件(位图)</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data; <span class="comment">// User data variable</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//往外取正在发生的事件</span></span><br><span class="line"><span class="comment">//epfd:用epoll_create创建的实例</span></span><br><span class="line"><span class="comment">//event:取出来的事件回填的地址(数组)</span></span><br><span class="line"><span class="comment">//maxevents:想要取多少个事件</span></span><br><span class="line"><span class="comment">//timeout:超时设置(毫秒),0-非阻塞,-1-阻塞</span></span><br><span class="line"><span class="comment">//返回：正数，有多少个文件描述符发生了关心的事件</span></span><br><span class="line"><span class="comment">//  0，没有发生事件超时返回</span></span><br><span class="line"><span class="comment">//  -1，出错并设置errno(EINTR是假错)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_pwait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>poll</code>是自己定义一个数组，每个元素就是一个文件描述符以及其关心和发生的事件，<code>epoll</code>是内核帮你维护了这样一个数组。<code>epoll_create()</code>就是创建这个数组，再用其他函数去访问/修改该数组。</p>
<h3 id="select-amp-poll-amp-epoll"><a href="#select-amp-poll-amp-epoll" class="headerlink" title="select&amp;poll&amp;epoll"></a>select&amp;poll&amp;epoll</h3><p><code>select()</code>缺点：</p>
<p>1.<code>fd_set</code>使用数组实现，<code>fd_size</code>有限制 1024<code>bitmap</code>，<code>fd[i] = accept()</code><br>2.<code>fdset</code>不可重用，新的fd进来，重新创建<br>3.用户态和内核态拷贝<code>bitmap</code>产生开销<br>4.<code>O(n)</code>时间复杂度的轮询(发生事件后的轮询)</p>
<p><code>poll</code>基于结构体存储fd，解决了<code>select</code>的缺点1,2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">short</span> events;</span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">//可重用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>epoll</code>:用户态和内核态不拷贝<code>bitmap</code>；返回结果不需要轮询，时间复杂度为<code>O(1)</code>，解决<code>select</code>的缺点1,2,3,4</p>
<TODO>

<p>epoll_create 创建一个白板 存放fd_events<br>epoll_ctl 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上<br>epoll_wait 通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符</p>
<p>两种触发模式：<br>LT:水平触发<br>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。<br>ET:边缘触发<br>和 LT 模式不同的是，通知之后进程必须立即处理事件。<br>下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，<br>因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2020/09/01/apue%E7%BA%BF%E7%A8%8B/">apue线程</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://humble-zh.github.io/page/5/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2020-09-01T03:41:53.000Z" itemprop="datePublished">2020-09-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/apue/" rel="tag">apue</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="apue线程"><a href="#apue线程" class="headerlink" title="apue线程"></a>apue线程</h1><h2 id="1-线程的概念"><a href="#1-线程的概念" class="headerlink" title="1.线程的概念"></a>1.线程的概念</h2><p>线程就是一个正在运行的函数。</p>
<p>实际项目中多线程用得比较多，因为多线程是先有标准后有实现的，所以不会向多进程那样在不同平台上有许多不同的情况。</p>
<p>C 语言线程有很多标准，POSIX 是其中的一种（还有比如openmp标准线程）。POSIX 是一套标准，而不是一种实现。所以 POSIX 只是规定了 pthread_t 作为线程标识符，但是并没有规定它必须是由什么类型组成的。在有的平台上它可能是 int，有些平台上它可能是 struct，还有些平台上它可能是 union，所以不要直接操作这个类型，而是要使用 POSIX 规定的各种线程函数来操作它。</p>
<p>有木有觉得像标准 IO 里 FILE 的赶脚？没错，标准制定出来的很多东西都是这种风格的，它为你提供一个数据类型而不让你直接对这个类型操作，要通过它定义的一系列函数来实现对这个类型的操作，这样就在各个平台上实现统一的接口了，所以这样做才能让标准制定出来的东西具有较好的可移植性。</p>
<p>pthread_t 是个很重要的东西，我们所有使用 POSIX 标准的线程操作都是围绕着它来进行的，通过它配合各种函数就可以对线程进行各种花样作死的玩了。:)</p>
<p>线程没有父子关系，是兄弟关系，可以相互收尸（别说主线程，建议说main线程）。线程间比进程间通讯简单，因为线程共用一片地址空间。</p>
<h3 id="查看线程"><a href="#查看线程" class="headerlink" title="查看线程"></a>查看线程</h3><p><code>ps axf</code> 查看进程关系</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># li @ evpower in ~ [14:31:02]</span></span><br><span class="line">$ ps axf</span><br><span class="line">    PID TTY      STAT   TIME COMMAND</span><br><span class="line">      2 ?        S      0:00 [kthreadd]</span><br><span class="line">      3 ?        I&lt;     0:00  \_ [rcu_gp]</span><br><span class="line">      4 ?        I&lt;     0:00  \_ [rcu_par_gp]</span><br><span class="line">      6 ?        I&lt;     0:00  \_ [kworker/0:0H-kblockd]</span><br><span class="line">      9 ?        I&lt;     0:00  \_ [mm_percpu_wq]</span><br><span class="line">...</span><br><span class="line">      1 ?        Ss     0:03 /sbin/init splash</span><br><span class="line">    689 ?        Ss     0:00 avahi-daemon: running [evpower.local]</span><br><span class="line">    738 ?        S      0:00  \_ avahi-daemon: chroot helper</span><br><span class="line">    701 ?        Ss     0:00 /usr/bin/python3 /usr/bin/networkd-dispatcher --run-startup-triggers</span><br><span class="line">    829 ?        Ssl    0:00 /usr/sbin/gdm3</span><br><span class="line">   1610 ?        Sl     0:00  \_ gdm-session-worker [pam/gdm-password]</span><br><span class="line">   1712 tty2     Ssl+   0:00      \_ /usr/lib/gdm3/gdm-x-session --register-session --run-script i3</span><br><span class="line">   1714 tty2     Sl+    2:09          \_ /usr/lib/xorg/Xorg vt2 -displayfd 3 -auth /run/user/1000/gdm/Xa</span><br><span class="line">   1745 tty2     S+     0:02          \_ i3</span><br><span class="line">   1824 ?        Ss     0:00              \_ /usr/bin/ssh-agent /usr/bin/im-launch i3</span><br></pre></td></tr></table></figure>
<p><code>ps axm</code> 查看进程详细信息，包括线程（<code>- -</code>表示线程）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    PID TTY      STAT   TIME COMMAND</span><br><span class="line">      1 ?        -      0:04 /sbin/init splash</span><br><span class="line">      - -        Ss     0:04 -</span><br><span class="line">      2 ?        -      0:00 [kthreadd]</span><br><span class="line">      - -        S      0:00 -</span><br><span class="line">      3 ?        -      0:00 [rcu_gp]</span><br><span class="line">      - -        I&lt;     0:00 -</span><br><span class="line">...</span><br><span class="line">    693 ?        -      0:03 /usr/sbin/NetworkManager --no-daemon</span><br><span class="line">      - -        Ssl    0:03 -</span><br><span class="line">      - -        Ssl    0:00 -</span><br><span class="line">      - -        Ssl    0:00 -</span><br><span class="line">    700 ?        -      0:00 /usr/sbin/irqbalance --foreground</span><br><span class="line">      - -        Ssl    0:00 -</span><br><span class="line">      - -        Ssl    0:00 -</span><br><span class="line">    701 ?        -      0:00 /usr/bin/python3 /usr/bin/networkd-dispatcher --run-startup-triggers</span><br><span class="line">      - -        Ss     0:00 -</span><br></pre></td></tr></table></figure>
<p><code>ps ax -L</code>也可以查进程与线程（<code>PID</code>是进程id,<code>LWP</code>是轻量级进程id，常称线程id，也占一个PID）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    PID     LWP TTY      STAT   TIME COMMAND</span><br><span class="line">      1       1 ?        Ss     0:04 /sbin/init splash</span><br><span class="line">      2       2 ?        S      0:00 [kthreadd]</span><br><span class="line">      3       3 ?        I&lt;     0:00 [rcu_gp]</span><br><span class="line">...</span><br><span class="line">    708     708 ?        Ssl    0:00 /usr/lib/policykit-1/polkitd --no-debug</span><br><span class="line">    708     715 ?        Ssl    0:00 /usr/lib/policykit-1/polkitd --no-debug</span><br><span class="line">    708     769 ?        Ssl    0:00 /usr/lib/policykit-1/polkitd --no-debug</span><br><span class="line">    710     710 ?        Ssl    0:00 /usr/sbin/rsyslogd -n -iNONE</span><br><span class="line">    710     764 ?        Ssl    0:00 /usr/sbin/rsyslogd -n -iNONE</span><br><span class="line">    710     765 ?        Ssl    0:00 /usr/sbin/rsyslogd -n -iNONE</span><br><span class="line">    710     766 ?        Ssl    0:00 /usr/sbin/rsyslogd -n -iNONE</span><br></pre></td></tr></table></figure>
<p>Linux以线程为维护单位，也就是PID，如果线程没有被收尸，那尸体就占用一个PID。</p>
<h3 id="pthread-equal"><a href="#pthread-equal" class="headerlink" title="pthread_equal"></a>pthread_equal</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较两个线程标识符是否相同，相同返回非0，不同则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> t1, <span class="keyword">pthread_t</span> t2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>为什么不能使用 <code>if (t1 == t2)</code> 的方式比较两个线程标识符呢？因为各系统实现不一样，你不知道 pthread_t 是什么类型的，所以永远不要自己直接操作它。</p>
<h3 id="pthread-self"><a href="#pthread-self" class="headerlink" title="pthread_self"></a>pthread_self</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得当前线程 ID，永远不出错</span></span><br><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="2-线程的创建-amp-终止-amp-取消-amp-栈清理"><a href="#2-线程的创建-amp-终止-amp-取消-amp-栈清理" class="headerlink" title="2.线程的创建&amp;终止&amp;取消&amp;栈清理"></a>2.线程的创建&amp;终止&amp;取消&amp;栈清理</h2><h3 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程，成功返回0，失败返回errno</span></span><br><span class="line"><span class="comment">//某些平台上 errno 是全局变量，为避免在多线程的情况下出现竞争，POSIX 指定在失败的时直接返回 errno</span></span><br><span class="line"><span class="comment">//创建后的线程id回填到thread</span></span><br><span class="line"><span class="comment">//attr指定创建线程具有的属性(常用NULL就够用)</span></span><br><span class="line"><span class="comment">//start_routine 指定函数也就是线程主体</span></span><br><span class="line"><span class="comment">//arg指定传给start_routine的参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a>pthread_exit</h3><p>线程终止有3中方式，<code>pthread_exit</code> 只是其一</p>
<ol>
<li>线程从启动例程返回，返回值就是线程退出码</li>
<li>线程可以被同一进程中的其他线程取消</li>
<li>线程调用<code>pthread_exit()</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//终止线程，并通过retval返回一个值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收thread的尸体，并把thread返回的值回填到retval</span></span><br><span class="line"><span class="comment">//成功返回0，失败返回errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure>
<p>类似进程里面的<code>wait()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Filename: creat1.c</span></span><br><span class="line"><span class="comment"> * No.83-84.线程-线程创建&amp;线程终止和栈清理</span></span><br><span class="line"><span class="comment"> * $ ps axm</span></span><br><span class="line"><span class="comment"> * $ ps ax -L</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * $ gcc -Wall creat1.c -o creat1 -lpthread</span></span><br><span class="line"><span class="comment"> * Last modified: humble 2020-09-01 15:29:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func %d\n&quot;</span>, *(<span class="keyword">int</span> *)p);</span><br><span class="line">    pthread_exit(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//pthread_exit(NULL);</span></span><br><span class="line">    <span class="comment">//return NULL; //pthread_exit可以实现线程清理，retuan NULL不可以</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> err = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, (<span class="keyword">void</span> *)&amp;i);</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程的调度取决于调度器的策略</span></span><br><span class="line">    <span class="comment">//调用pthread_create后，可能main线程先往下运行，也可能func线程先运行</span></span><br><span class="line">    <span class="comment">//所以&quot;func 7&quot;和&quot;main&quot;打印顺序可能不确定</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//sleep(1);</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;main&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为tid收尸，并用retval接收tid返回值</span></span><br><span class="line">    pthread_join(tid, &amp;retval); <span class="comment">//类似进程的wati()</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end %d\n&quot;</span>, retval);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mi @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [18:32:28]</span></span><br><span class="line">$ gcc -Wall creat1.c -o creat1 -lpthread</span><br><span class="line">creat1.c: In <span class="keyword">function</span> ‘func’:</span><br><span class="line">creat1.c:18:18: warning: passing argument 1 of ‘pthread_exit’ makes pointer from <span class="built_in">integer</span> without a cast [-Wint-conversion]</span><br><span class="line">   18 |     pthread_exit(3);</span><br><span class="line">      |                  ^</span><br><span class="line">      |                  |</span><br><span class="line">      |                  int</span><br><span class="line">In file included from creat1.c:12:</span><br><span class="line">/usr/include/pthread.h:207:33: note: expected ‘void *’ but argument is of <span class="built_in">type</span> ‘int’</span><br><span class="line">  207 | extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));</span><br><span class="line">      |                           ~~~~~~^~~~~~~~</span><br><span class="line">creat1.c: In <span class="keyword">function</span> ‘main’:</span><br><span class="line">creat1.c:44:23: warning: passing argument 2 of ‘pthread_join’ from incompatible pointer <span class="built_in">type</span> [-Wincompatible-pointer-types]</span><br><span class="line">   44 |     pthread_join(tid, &amp;retval); //类似进程的wati()</span><br><span class="line">      |                       ^~~~~~~</span><br><span class="line">      |                       |</span><br><span class="line">      |                       int *</span><br><span class="line">In file included from creat1.c:12:</span><br><span class="line">/usr/include/pthread.h:215:49: note: expected ‘void **’ but argument is of <span class="built_in">type</span> ‘int *’</span><br><span class="line">  215 | extern int pthread_join (pthread_t __th, void **__thread_return);</span><br><span class="line">      |                                          ~~~~~~~^~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="comment"># mi @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [18:40:25]</span></span><br><span class="line">$ ./creat1</span><br><span class="line">begin</span><br><span class="line">main</span><br><span class="line">func 2</span><br><span class="line">end 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># mi @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [18:40:27]</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="栈清理"><a href="#栈清理" class="headerlink" title="栈清理"></a>栈清理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//挂钩子函数 routine</span></span><br><span class="line"><span class="comment">//arg指定传给routine 的参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="keyword">void</span> (*routine)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据 execute 值为真/假判断是否调用钩子函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span>;</span><br></pre></td></tr></table></figure>
<p>类似<code>atexit()</code>挂钩子函数。用钩子函数对线程进行清理，钩子函数被调用顺序跟注册时相反。</p>
<p>这两个是带参的宏而不是函数，所以必须成对使用，而且必须先使用 pthread_cleanup_push 再使用  pthread_cleanup_pop，否则会报语法错误，括号不匹配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Filename: cleanup.c</span></span><br><span class="line"><span class="comment"> * No.84.线程-线程终止和栈清理</span></span><br><span class="line"><span class="comment"> * $ ps axm</span></span><br><span class="line"><span class="comment"> * $ ps ax -L</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * $ gcc -Wall cleanup.c -o cleanup -lpthread</span></span><br><span class="line"><span class="comment"> * Last modified: humble 20200411 17:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//pthread_cleanup_push 和 pthread_cleanup_pop 需要成对使用，位置无所谓</span></span><br><span class="line"><span class="comment">//demo 不为0或1，则编译报错</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> demo (0) <span class="comment">//1</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func_cleanup</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;pthread func is working&quot;</span>);</span><br><span class="line">    pthread_cleanup_push(func_cleanup, <span class="string">&quot;cleanup1&quot;</span>);</span><br><span class="line">    pthread_cleanup_push(func_cleanup, <span class="string">&quot;cleanup2&quot;</span>);</span><br><span class="line">    pthread_cleanup_push(func_cleanup, <span class="string">&quot;cleanup3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;push over&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (demo == 0)</span></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (demo == 1)</span></span><br><span class="line">    <span class="comment">//如果 pthread_cleanup_pop 放在pthread_exit后面，传参execute永远为真</span></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> err = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mi @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [19:07:58]</span></span><br><span class="line">$ gcc -Wall cleanup.c -o cleanup -lpthread <span class="comment">#demo0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mi @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [19:08:00]</span></span><br><span class="line">$ ./cleanup</span><br><span class="line">begin</span><br><span class="line">pthread func is working</span><br><span class="line">push over</span><br><span class="line">cleanup3</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment"># mi @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [19:08:04]</span></span><br><span class="line">$ vi cleanup.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># mi @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [19:08:13]</span></span><br><span class="line">$ gcc -Wall cleanup.c -o cleanup -lpthread <span class="comment">#demo1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mi @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [19:08:24]</span></span><br><span class="line">$ ./cleanup</span><br><span class="line">begin</span><br><span class="line">pthread func is working</span><br><span class="line">push over</span><br><span class="line">cleanup3</span><br><span class="line">cleanup2</span><br><span class="line">cleanup1</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment"># mi @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [19:08:26]</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消同一进程中的线程thread</span></span><br><span class="line"><span class="comment">//成功返回0，失败返回errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当一个线程没有必要继续执行下去时，又没法直接为它收尸，就需要先<code>pthread_cancel</code>取消这个线程，再<code>pthread_join</code>收尸。</p>
<p>如：多线程遍历一个很大的二叉树查找一个数据时，某一个线程找到了数据，那其它线程就没有必要继续执行了，可以取消它们了。</p>
<p>注意<code>pthread_cancel()</code>并不等待线程终止，它仅仅提出请求。 而目标线程收到这个请求也不会立即终止，要执行到取消点才能被取消。</p>
<p>取消有2种状态：</p>
<ul>
<li>允许<ul>
<li>异步cancel</li>
<li>推迟cancel(默认) 推迟至cancel点再取消</li>
</ul>
</li>
<li>不允许。</li>
</ul>
<p>POSIX 定义的cancel点，都是可能引发阻塞的系统调用(比如open(),read(),write()..)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fd1 = open();</span><br><span class="line"><span class="comment">// if err</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fd1刚打开，就收到一个pthread_cancel(但这里不是cancel点，所以不会响应)</span></span><br><span class="line"><span class="comment">//&#x27;可能引发阻塞的系统调用&#x27;才是POSIX定义的cancel点，要执行到下一个cancel点才会响应</span></span><br><span class="line"><span class="comment">//所以，在下一个cancel点之前可以挂钩子函数去关闭/释放资源</span></span><br><span class="line">pthread_cleanup_push(close(fd1));</span><br><span class="line"></span><br><span class="line">fd2 = open();</span><br><span class="line"><span class="comment">// if err</span></span><br><span class="line"></span><br><span class="line">pthread_cleanup_push(close(fd2));</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="pthread-setcanceltype"><a href="#pthread-setcanceltype" class="headerlink" title="pthread_setcanceltype"></a>pthread_setcanceltype</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置是否允许被取消</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcancelstate</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span> *oldstate)</span></span>;</span><br><span class="line"><span class="comment">//设置取消方式(异步cancel还是推迟cancel)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> *oldtype)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="pthread-testcancel"><a href="#pthread-testcancel" class="headerlink" title="pthread_testcancel"></a>pthread_testcancel</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//什么都不做，充当一个cancel点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_testcancel</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分离一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>
<p>习惯上谁创建线程谁<code>pthread_join</code>收尸。当分离了thread线程，那就不能为其收尸。</p>
<h3 id="例0：多线程筛质数"><a href="#例0：多线程筛质数" class="headerlink" title="例0：多线程筛质数"></a>例0：多线程筛质数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Filename: primer0.c</span></span><br><span class="line"><span class="comment"> * No.86.线程-线程竞争实例</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * 多线程去计算某一范围内的质数</span></span><br><span class="line"><span class="comment"> * $ gcc -Wall primer0.c -o primer0 -lpthread</span></span><br><span class="line"><span class="comment"> * Last modified: humble 2020-09-01 21:04:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (30000000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (30000200)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (RIGHT - LEFT +1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_primer</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++)&#123;</span><br><span class="line">        err = pthread_create(tid + (i - LEFT), <span class="literal">NULL</span>, thr_primer, (<span class="keyword">void</span> *)i); <span class="comment">//如果把i的地址则会有竞争</span></span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="comment">//发生错误就收尸已经创建成功的线程</span></span><br><span class="line">            <span class="comment">//while(--i &lt; 0)&#123; pthread_join(tid[i - LEFT], NULL); &#125; //未测</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++)&#123; <span class="comment">//收尸</span></span><br><span class="line">        pthread_join(tid[i - LEFT], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_primer</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    i = (<span class="keyword">int</span>)p;</span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mark == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mi @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [21:08:38]</span></span><br><span class="line">$ gcc -Wall primer0.c -o primer0 -lpthread</span><br><span class="line">primer0.c: In <span class="keyword">function</span> ‘main’:</span><br><span class="line">primer0.c:25:66: warning: cast to pointer from <span class="built_in">integer</span> of different size [-Wint-to-pointer-cast]</span><br><span class="line">   25 |         err = pthread_create(tid + (i - LEFT), NULL, thr_primer, (void *)i); //如果把i的地址则会有竞争</span><br><span class="line">      |                                                                  ^</span><br><span class="line">primer0.c: In <span class="keyword">function</span> ‘thr_primer’:</span><br><span class="line">primer0.c:45:9: warning: cast from pointer to <span class="built_in">integer</span> of different size [-Wpointer-to-int-cast]</span><br><span class="line">   45 |     i = (int)p;</span><br><span class="line">      |         ^</span><br><span class="line"></span><br><span class="line"><span class="comment"># mi @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [21:08:40]</span></span><br><span class="line">$ ./primer0</span><br><span class="line">30000059 is a primer</span><br><span class="line">30000071 is a primer</span><br><span class="line">30000083 is a primer</span><br><span class="line">30000023 is a primer</span><br><span class="line">30000137 is a primer</span><br><span class="line">30000001 is a primer</span><br><span class="line">30000041 is a primer</span><br><span class="line">30000199 is a primer</span><br><span class="line">30000193 is a primer</span><br><span class="line">30000037 is a primer</span><br><span class="line">30000149 is a primer</span><br><span class="line">30000049 is a primer</span><br><span class="line">30000109 is a primer</span><br><span class="line">30000169 is a primer</span><br><span class="line">30000163 is a primer</span><br><span class="line">30000167 is a primer</span><br><span class="line">30000133 is a primer</span><br><span class="line">30000079 is a primer</span><br><span class="line"></span><br><span class="line"><span class="comment"># mi @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [21:09:12]</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="例e：多线程筛质数"><a href="#例e：多线程筛质数" class="headerlink" title="例e：多线程筛质数"></a>例e：多线程筛质数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Filename: primer0_e.c</span></span><br><span class="line"><span class="comment"> * No.87.线程-线程竞争实例2</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * 多线程去计算某一范围内的质数</span></span><br><span class="line"><span class="comment"> * $ gcc -Wall primer0_e.c -o primer0_e -lpthread</span></span><br><span class="line"><span class="comment"> * Last modified: humble 2020-09-01 21:14:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (30000000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (30000200)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (RIGHT - LEFT +1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;<span class="keyword">thrarg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_primer</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">thrarg_t</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">thrarg_t</span>));</span><br><span class="line">        <span class="keyword">if</span>(!p)&#123;</span><br><span class="line">            perror(<span class="string">&quot;malloc()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;n = i;</span><br><span class="line"></span><br><span class="line">        err = pthread_create(tid + (i - LEFT), <span class="literal">NULL</span>, thr_primer, p);</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="comment">//while(--i &lt; 0)&#123; pthread_join(tid[i - LEFT], NULL);free(.ptr.); &#125; //未测</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++)&#123;</span><br><span class="line">        pthread_join(tid[i - LEFT], &amp;ptr);</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_primer</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    i = ((<span class="keyword">thrarg_t</span> *)p)-&gt;n;</span><br><span class="line">    <span class="comment">//free(p);</span></span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mark == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(p); <span class="comment">//把p返回给pthread_join</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果同上。例子创建了200个线程，但能进程空间允许创建的线程数量有限（可能PID耗尽，也可能栈空间耗尽）。每个线程消耗一个PID，并且消耗一份栈空间<code>ulimit -s</code>(32位进程栈最多创建约300个线程)，使用线程属性修改线程栈大小可提高最大线程创建量。使用<code>ulimit -a</code>命令可以查看所有资源上限。</p>
<h2 id="3-线程同步"><a href="#3-线程同步" class="headerlink" title="3.线程同步"></a>3.线程同步</h2><h3 id="互斥量-pthead-mutex-t"><a href="#互斥量-pthead-mutex-t" class="headerlink" title="互斥量(pthead_mutex_t)"></a>互斥量(pthead_mutex_t)</h3><p>可以使各个线程实现互斥的效果。由它来保护临界区每次只能由一个线程进入。当一个线程想要进入临界区之前需要先抢锁（加锁），如果能抢到锁就进入临界区工作，并且要在离开的时候解锁以便让其它线程可以抢到锁进入临界区；如果没有抢到锁则进入阻塞状态等待锁被释放然后再抢锁。</p>
<p>要在进入临界区之前加锁，在退出临界区的时候解锁。临界区是每个线程要单独执行的，所以临界区中的代码执行时间越短越好。互斥量限制的是一段代码能否执行，而不是一个变量或一个资源。</p>
<p>防止死锁：在临界区内跳转到临界区外时记得先解锁。</p>
<h3 id="pthread-mutex-xxx"><a href="#pthread-mutex-xxx" class="headerlink" title="pthread_mutex_xxx"></a>pthread_mutex_xxx</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态初始化，定义mutex时用宏初始化，使用默认属性</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态初始化，先定义未被初始化的mutex，再用 pthread_mutex_init 函数对mutex初始化，并指定属性mutexattr。返回0（永远不出错）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *mutexattr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁mutex锁，成功返回0，失败返回errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//阻塞死等抢锁，成功返回0，失败返回errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非死等抢锁，成功返回0，失败返回errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解锁，成功返回0，失败返回errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="例：多线程读写文件"><a href="#例：多线程读写文件" class="headerlink" title="例：多线程读写文件"></a>例：多线程读写文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Filename: add.c</span></span><br><span class="line"><span class="comment"> * No.88.线程-竞争故障</span></span><br><span class="line"><span class="comment"> * Description: 线程冲突(线程互斥量)</span></span><br><span class="line"><span class="comment"> * $ gcc -Wall add.c -o add -lpthread</span></span><br><span class="line"><span class="comment"> * $ echo 1 &gt; /tmp/out</span></span><br><span class="line"><span class="comment"> * $ ./add &amp;&amp; cat /tmp/out</span></span><br><span class="line"><span class="comment"> * Last modified: humble 2020-09-02 09:03:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (20)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINEBUFSIZE (1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">&quot;/tmp/out&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//demo0 不带互斥量，同时读写资源发生冲突</span></span><br><span class="line"><span class="comment">//demo1 使用互斥量，争抢资源，非同时读写</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> demo (1) <span class="comment">//0,1</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (demo == 1)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_add</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> linebuf[LINEBUFSIZE];</span><br><span class="line"></span><br><span class="line">    fp = fopen(FNAME, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!fp)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (demo == 1)</span></span><br><span class="line">    pthread_mutex_lock(&amp;mut);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    fgets(linebuf, LINEBUFSIZE, fp);</span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (demo == 0)</span></span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">//扩大竞争时间域，等全部线程都读取完毕，再往下操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d\n&quot;</span>, atoi(linebuf) + <span class="number">1</span>);</span><br><span class="line">    fclose(fp); <span class="comment">//刷新缓冲区，不能放到unlock后面</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (demo == 1)</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mut);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++)&#123;</span><br><span class="line">        err = pthread_create(tid + i, <span class="literal">NULL</span>, thr_add, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="comment">//while(--i &lt; 0)&#123; pthread_join(tid[i - LEFT], NULL); &#125; //未测</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++)&#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (demo == 1)</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mut); <span class="comment">//对应 pthread_mutex_init()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># li @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [9:46:35]</span></span><br><span class="line">$ gcc -Wall add.c -o add -lpthread <span class="comment">#demo0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># li @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [9:46:40]</span></span><br><span class="line">$ <span class="built_in">echo</span> 1 &gt; /tmp/out</span><br><span class="line"></span><br><span class="line"><span class="comment"># li @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [9:46:42]</span></span><br><span class="line">$ ./add</span><br><span class="line"></span><br><span class="line"><span class="comment"># li @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [9:46:46]</span></span><br><span class="line">$ cat /tmp/out</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line"><span class="comment"># li @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [9:46:48]</span></span><br><span class="line">$ vi add.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># li @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [9:47:07]</span></span><br><span class="line">$ gcc -Wall add.c -o add -lpthread <span class="comment">#demo1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># li @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [9:47:10]</span></span><br><span class="line">$ <span class="built_in">echo</span> 1 &gt; /tmp/out</span><br><span class="line"></span><br><span class="line"><span class="comment"># li @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [9:47:12]</span></span><br><span class="line">$ ./add</span><br><span class="line"></span><br><span class="line"><span class="comment"># li @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [9:47:14]</span></span><br><span class="line">$ cat /tmp/out</span><br><span class="line">21</span><br><span class="line"></span><br><span class="line"><span class="comment"># li @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [9:47:16]</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="例：4个线程分别打印abcd，且按顺序，持续5秒"><a href="#例：4个线程分别打印abcd，且按顺序，持续5秒" class="headerlink" title="例：4个线程分别打印abcd，且按顺序，持续5秒"></a>例：4个线程分别打印abcd，且按顺序，持续5秒</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Filename: abcd.c</span></span><br><span class="line"><span class="comment"> * No.89.线程-互斥量</span></span><br><span class="line"><span class="comment"> * Description:4个线程分别打印abcd，且按顺序，持续5秒</span></span><br><span class="line"><span class="comment"> * $ gcc -Wall abcd.c -o abcd -lpthread</span></span><br><span class="line"><span class="comment"> * Last modified: humble 2020-09-02 10:06:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (4)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut[THRNUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n + <span class="number">1</span> == THRNUM)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_abcd</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)p;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="string">&#x27;a&#x27;</span> + (<span class="keyword">int</span>)p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(mut + n); <span class="comment">//死等着抢属于自己的锁</span></span><br><span class="line">        write(<span class="number">1</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line">        pthread_mutex_unlock(mut + next(n)); <span class="comment">//放开下一个人的锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_init(mut + i, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_mutex_lock(mut + i); <span class="comment">//初始化完，立刻抢锁</span></span><br><span class="line">        err = pthread_create(tid + i, <span class="literal">NULL</span>, thr_abcd, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="comment">//while(--i &lt; 0)&#123; pthread_join(tid[i - LEFT], NULL); &#125; //未测</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程创建完毕时全部锁都抢到了</span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(mut + <span class="number">0</span>); <span class="comment">//放开a的锁</span></span><br><span class="line">    alarm(<span class="number">5</span>); <span class="comment">//5秒钟后进程被信号杀死</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># li @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [11:20:10] C:142</span></span><br><span class="line">$ gcc -Wall abcd.c -o abcd -lpthread</span><br><span class="line">abcd.c: In <span class="keyword">function</span> ‘thr_abcd’:</span><br><span class="line">abcd.c:29:13: warning: cast from pointer to <span class="built_in">integer</span> of different size [-Wpointer-to-int-cast]</span><br><span class="line">   29 |     int n = (int)p;</span><br><span class="line">      |             ^</span><br><span class="line">abcd.c:30:19: warning: cast from pointer to <span class="built_in">integer</span> of different size [-Wpointer-to-int-cast]</span><br><span class="line">   30 |     int c = <span class="string">&#x27;a&#x27;</span> + (int)p;</span><br><span class="line">      |                   ^</span><br><span class="line">abcd.c: In <span class="keyword">function</span> ‘main’:</span><br><span class="line">abcd.c:49:55: warning: cast to pointer from <span class="built_in">integer</span> of different size [-Wint-to-pointer-cast]</span><br><span class="line">   49 |         err = pthread_create(tid + i, NULL, thr_abcd, (void *)i);</span><br><span class="line">      |                                                       ^</span><br><span class="line"></span><br><span class="line"><span class="comment"># li @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [11:21:54]</span></span><br><span class="line">$ ./abcd</span><br><span class="line">abcdabcdabcdabcdabcdabcdabcda...</span><br><span class="line">[1]    20197 alarm      ./abcd</span><br></pre></td></tr></table></figure>
<h3 id="让出cpu"><a href="#让出cpu" class="headerlink" title="让出cpu"></a>让出cpu</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让出当前线程所占用的调度器给其它线程使用，而不必等待时间片耗尽才切换调度器</span></span><br><span class="line"><span class="comment">//成功返回0，失败返回-1并设置errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_yield</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以把它理解成一个很短暂的 <code>sleep()</code> 。一般用于在使用一个资源时需要同时获得多把锁但是却没法一次性获得全部的锁的场景下，只要有任何一把锁没有抢到，那么就立即释放已抢到的锁，并让出自己的调度器让其它线程有机会获得被自己释放的锁。当再次调度到自己时再重新抢锁，直到能一次性抢到所有的锁时再进入临界区，这样就避免了出现死锁的情况。</p>
<h3 id="例：N个线程去计算某一范围内的质数"><a href="#例：N个线程去计算某一范围内的质数" class="headerlink" title="例：N个线程去计算某一范围内的质数"></a>例：N个线程去计算某一范围内的质数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Filename: primer0_pool.c</span></span><br><span class="line"><span class="comment"> * No.90.线程-线程池实现</span></span><br><span class="line"><span class="comment"> * Description: N个线程去计算某一范围内的质数</span></span><br><span class="line"><span class="comment"> * 查询法/忙等版，main和多个thr_primer一起抢锁，会出现main长时间抢不到锁的情况</span></span><br><span class="line"><span class="comment"> * $ gcc -Wall primer0_pool.c -o primer0_pool -lpthread</span></span><br><span class="line"><span class="comment"> * Last modified: humble 2020-09-02 15:18:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (30000000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (30000200)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (4)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//猪圈</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut_num = PTHREAD_MUTEX_INITIALIZER; <span class="comment">//猪圈锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_primer</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程(创建4头猪)</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= THRNUM; i++)&#123;</span><br><span class="line">        err = pthread_create(tid + i, <span class="literal">NULL</span>, thr_primer, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="comment">//while(--i &lt; 0)&#123; pthread_join(tid[i], NULL); &#125; //未测</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//main把数字投放到num里面(主人把猪食扔到猪圈里)</span></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num); <span class="comment">//抢猪圈的锁</span></span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//上一份猪食居然还没被猪吃掉</span></span><br><span class="line">            <span class="comment">//解锁猪圈，好让猪能抢锁进猪圈吃掉</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            <span class="comment">//因为有可能某个thr_primer(猪)抢到也可能又被main(主人)抢到</span></span><br><span class="line">            <span class="comment">//所以操作调度器，让出cpu(可理解为段时间sleep)，避免接下来又是main(主人)抢到锁</span></span><br><span class="line">            sched_yield();</span><br><span class="line">            pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        &#125;</span><br><span class="line">        num = i; <span class="comment">//上一份猪食被猪吃掉了，投放猪食</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num); <span class="comment">//解锁猪圈，好让猪能抢锁进猪圈吃掉</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//到此，猪食已经投完了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//等猪取走猪食后，往猪圈投放一份猪粪(-1)，让猪别再抢锁进猪圈</span></span><br><span class="line">    pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//上一份猪食居然还没被猪吃掉</span></span><br><span class="line">        <span class="comment">//解锁猪圈，好让猪能抢锁进猪圈吃掉</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">        <span class="comment">//因为有可能别的thr_primer(猪)抢到也可能又被自己抢到</span></span><br><span class="line">        <span class="comment">//所以操作调度器，让出cpu(可理解为段时间sleep)，避免接下来又是main(主人)抢到锁</span></span><br><span class="line">        sched_yield();</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    &#125;</span><br><span class="line">    num = <span class="number">-1</span>; <span class="comment">//猪食被猪吃光了，投放猪粪(-1)</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mut_num); <span class="comment">//解锁猪圈，好让猪能抢锁进猪圈来发现猪粪(-1)而结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mut_num);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_primer</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num); <span class="comment">//猪抢到锁</span></span><br><span class="line">        <span class="keyword">while</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//发现猪圈是空的</span></span><br><span class="line">            <span class="comment">//解锁给main(主人)去投放猪食(有可能被其他thr_primer(猪)抢到)</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            sched_yield();  <span class="comment">//让出cpu，避免接下来又是自己抢到锁</span></span><br><span class="line">            pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//猪圈终于有东西了</span></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//居然是猪粪，释放锁</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//准备自杀</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是猪食，取走，释放锁给主人或其他猪去抢</span></span><br><span class="line">        i = num;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开吃</span></span><br><span class="line">        mark = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">                mark = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mark == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] %d is a primer\n&quot;</span>, (<span class="keyword">int</span>)p, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># li @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [15:10:33]</span></span><br><span class="line">$ gcc -Wall primer0_pool.c -o primer0_pool -lpthread</span><br><span class="line">primer0_pool.c: In <span class="keyword">function</span> ‘main’:</span><br><span class="line">primer0_pool.c:30:57: warning: cast to pointer from <span class="built_in">integer</span> of different size [-Wint-to-pointer-cast]</span><br><span class="line">   30 |         err = pthread_create(tid + i, NULL, thr_primer, (void *)i);</span><br><span class="line">      |                                                         ^</span><br><span class="line">primer0_pool.c: In <span class="keyword">function</span> ‘thr_primer’:</span><br><span class="line">primer0_pool.c:115:45: warning: cast from pointer to <span class="built_in">integer</span> of different size [-Wpointer-to-int-cast]</span><br><span class="line">  115 |             <span class="built_in">printf</span>(<span class="string">&quot;[%d] %d is a primer\n&quot;</span>, (int)p, i);</span><br><span class="line">      |                                             ^</span><br><span class="line"></span><br><span class="line"><span class="comment"># li @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [15:17:54]</span></span><br><span class="line">$ ./primer0_pool</span><br><span class="line">[0] 30000001 is a primer</span><br><span class="line">[1] 30000023 is a primer</span><br><span class="line">[3] 30000041 is a primer</span><br><span class="line">[2] 30000037 is a primer</span><br><span class="line">[4] 30000049 is a primer</span><br><span class="line">[0] 30000059 is a primer</span><br><span class="line">[4] 30000083 is a primer</span><br><span class="line">[3] 30000071 is a primer</span><br><span class="line">[2] 30000109 is a primer</span><br><span class="line">[1] 30000079 is a primer</span><br><span class="line">[4] 30000137 is a primer</span><br><span class="line">[3] 30000149 is a primer</span><br><span class="line">[0] 30000133 is a primer</span><br><span class="line">[4] 30000169 is a primer</span><br><span class="line">[3] 30000193 is a primer</span><br><span class="line">[2] 30000163 is a primer</span><br><span class="line">[1] 30000167 is a primer</span><br><span class="line">[0] 30000199 is a primer</span><br><span class="line"></span><br><span class="line"><span class="comment"># li @ evpower in ~/humble/tmp/lhq/parallel/thread/posix on git:master x [15:17:56]</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="pthread-once"><a href="#pthread-once" class="headerlink" title="pthread_once"></a>pthread_once</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个 控制执行一次 的变量</span></span><br><span class="line"><span class="keyword">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 once_control 的变量判断对init_routine()进行调用</span></span><br><span class="line"><span class="comment">//动态单次初始化，它能保证 init_routine 函数仅被调用一次</span></span><br><span class="line"><span class="comment">//返回0永远不出错</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_once</span><span class="params">(<span class="keyword">pthread_once_t</span> *once_control, <span class="keyword">void</span> (*init_routine) (<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="例：查询法令牌桶"><a href="#例：查询法令牌桶" class="headerlink" title="例：查询法令牌桶"></a>例：查询法令牌桶</h3><p>把令牌桶写成库的方式提供给它人调用，需要解决并发调用的资源竞争问题。另外实现只在第一次使用时才加载模块<code>module_load()</code>，类似C++的构造函数。</p>
<p>在临界区需要调用一个函数，但是从程序的布局来看该函数内无法通过加锁来避免并发冲突/函数重入。根据 POSIX 标准的约定，这种函数的命名规则是必须以 _unlocked 作为后缀，所以大家在看到这样的函数时在调用之前一定要先加锁。例如下面代码中的 <code>get_free_pos_unlocked()</code>。</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/humble-zh/studyapue/tree/master/parallel/thread/posix/mytbf_mt">查看代码</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./parallel/thread/posix/mytbf_mt/</span><br><span class="line"><span class="comment">#define demo (mutex_only)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mi @ evpower in ~/humble/tmp/lhq/parallel/thread/posix/mytbf_mt on git:master x [19:17:09] C:2</span></span><br><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── main.c</span><br><span class="line">├── Makefile</span><br><span class="line">├── mytbf.c</span><br><span class="line">└── mytbf.h</span><br><span class="line"></span><br><span class="line">0 directories, 4 files</span><br><span class="line"></span><br><span class="line"><span class="comment"># mi @ evpower in ~/humble/tmp/lhq/parallel/thread/posix/mytbf_mt on git:master x [19:17:10]</span></span><br><span class="line">$ make</span><br><span class="line">cc -Wall   -c -o main.o main.c</span><br><span class="line">cc -Wall   -c -o mytbf.o mytbf.c</span><br><span class="line">gcc -Wall main.o mytbf.o -o mytbf -lpthread</span><br><span class="line"></span><br><span class="line"><span class="comment"># mi @ evpower in ~/humble/tmp/lhq/parallel/thread/posix/mytbf_mt on git:master x [19:17:16]</span></span><br><span class="line">$ ./mytbf /etc/services</span><br><span class="line"><span class="comment"># Network services, Internet style</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that i^C</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mi @ evpower in ~/humble/tmp/lhq/parallel/thread/posix/mytbf_mt on git:master x [19:17:29] C:130</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>上面的程序经过测试，发现 CPU 正在满负荷工作，说明程序中出现了忙等。就是 <code>mytbf_fetchtoken()</code> 函数获得锁的时候采用了忙等的方式。异步程序有两种处理方式，一种是通知法，一种是查询法。我们这里用的就是查询法，下面改成通知法实现。</p>
<h3 id="条件变量-pthead-cond-t"><a href="#条件变量-pthead-cond-t" class="headerlink" title="条件变量(pthead_cond_t)"></a>条件变量(pthead_cond_t)</h3><p>让线程以无竞争的形式等待某个条件的发生，当条件发生时通知等待的线程醒来去做某件事。另一种方式是把所有等待同一个条件的线程都唤醒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态初始化，定义cond时用宏初始化，使用默认属性</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态初始化，先定义未被初始化的cond，再用 pthread_cond_init 函数对cond初始化，并指定属性cond_attr</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_condattr_t</span> *cond_attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数用于唤醒当前多个等待的线程中的任何一个</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//惊群，将现在正在等待的线程全部唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在临界区外阻塞等待某一个条件发生变化，(死等)直到有一个通知到来打断它的等待，被唤醒后开始抢mutex锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加了超时功能的等待，(尝试等)超时之后无论能否拿到锁都返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> struct  timespec</span></span></span><br><span class="line"><span class="function"><span class="params">*abstime)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁cond锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全部函数成功返回0，失败返回errno</span></span><br></pre></td></tr></table></figure>
<p>把查询法（忙等）修改为通知法（非忙等）仅仅加一个条件变量（pthread_cond_t） 就行了。</p>
<h3 id="例：通知法实现令牌桶"><a href="#例：通知法实现令牌桶" class="headerlink" title="例：通知法实现令牌桶"></a>例：通知法实现令牌桶</h3><p><a target="_blank" rel="noopener" href="https://gitee.com/humble-zh/studyapue/tree/master/parallel/thread/posix/mytbf_mt">查看代码</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./parallel/thread/posix/mytbf_mt/</span><br><span class="line"><span class="comment">#define demo (with_cond)</span></span><br></pre></td></tr></table></figure>
<p>通常<code>cond_wait()</code>等待会放在一个循环中，就像上面的令牌桶栗子一样，因为可能有多个线程都在等待条件满足，当前的线程’等待条件’被唤醒时不代表’执行条件’一定满足。可能先被唤醒的线程发现条件满足已经去工作了，等轮到当前线程调度的时候条件可能就又不满足了，所以如果条件不满足又通过<code>while</code>继续进入等待。</p>
<p>用 pthread_cond_signal(3) 还是用 pthread_cond_broadcast(3) 呢？</p>
<p>根据具体场景来选择。一般只有一个线程在等待或者明确知道哪个线程应该被唤醒的时候使用 _signal() 函数，如果有多个线程在等待并且不确定应该由谁起来工作的时候使用惊群。不确定是指业务上不能确定哪个线程应该工作，而不是你作为程序猿稀里糊涂的不知道哪个线程该工作。程序猿应该保证了解你的每一行代码在做什么，而不要写出一坨自己都不知道它在做什么的代码。</p>
<h2 id="4-线程属性-amp-同步属性"><a href="#4-线程属性-amp-同步属性" class="headerlink" title="4.线程属性&amp;同步属性"></a>4.线程属性&amp;同步属性</h2><h2 id="5-重入-amp-线程与信号-amp-线程与fork"><a href="#5-重入-amp-线程与信号-amp-线程与fork" class="headerlink" title="5.重入&amp;线程与信号&amp;线程与fork"></a>5.重入&amp;线程与信号&amp;线程与fork</h2>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2020/08/31/apue_78%E4%BF%A1%E5%8F%B7sigsuspend/">apue_78信号sigsuspend</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://humble-zh.github.io/page/5/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2020-08-31T02:42:38.000Z" itemprop="datePublished">2020-08-31</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/apue/" rel="tag">apue</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="apue-78信号sigsuspend"><a href="#apue-78信号sigsuspend" class="headerlink" title="apue_78信号sigsuspend"></a>apue_78信号sigsuspend</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Filename: susp.c</span></span><br><span class="line"><span class="comment"> * No.78.信号sigsuspend</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * 1.屏蔽信号</span></span><br><span class="line"><span class="comment"> * 2.打印5个*换行后</span></span><br><span class="line"><span class="comment"> * 3.取消信号屏蔽并且等信号</span></span><br><span class="line"><span class="comment"> * 4.收到信号后回到1</span></span><br><span class="line"><span class="comment"> * Last modified: humble 20200404 17:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SAVESET_ (1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> demo (2) <span class="comment">//0,1,2</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int_handler</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;!&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>, oset, saveset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;argc !=1&quot;</span>);</span><br><span class="line">        usage();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signal(SIGINT, int_handler);</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _SAVESET_</span></span><br><span class="line">    <span class="comment">//此句目的在于保存当前mask到saveset，方便以后恢复，用SIG_UNBLOCK或SIG_BLOCK都无所谓</span></span><br><span class="line">    sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, &amp;saveset);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (demo == 1) || (demo == 2)</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oset); <span class="comment">//block住</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (demo == 0)</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oset);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            write(<span class="number">1</span>, <span class="string">&quot;*&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (demo == 0)</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;oset, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//因为sigprocmask和pause两个函数不原子</span></span><br><span class="line">        <span class="comment">//如果在sigprocmask和pause之间收到信号，那响应完信号之后进入了pause</span></span><br><span class="line">        <span class="comment">//可是我们期望它响应信号后能继续打印*</span></span><br><span class="line">        pause();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (demo == 1)</span></span><br><span class="line">        <span class="keyword">sigset_t</span> tmpset;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;oset, &amp;tmpset); <span class="comment">//恢复unblock，并用tmpset记录block集(set和tmpset相同)</span></span><br><span class="line">        <span class="comment">//sigprocmask和pause两个函数不原子，结果跟demo0一样</span></span><br><span class="line">        pause();</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;tmpset, <span class="literal">NULL</span>); <span class="comment">//再次block</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (demo == 2)</span></span><br><span class="line">        <span class="comment">//sigsuspend 就相当于上面demo1的原子操作</span></span><br><span class="line">        sigsuspend(&amp;oset);<span class="comment">//原子化 unblock后立刻进入pause(wait)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _SAVESET_</span></span><br><span class="line">    <span class="comment">//把mask设置为saveset(相当于恢复了之前的状态)</span></span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;saveset, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USAGE <span class="meta-string">&quot;Usage:\n\</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">  Helloworld\n&quot;</span></span></span><br><span class="line">    <span class="built_in">printf</span>(USAGE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/humble/tmp/lhq/parallel/signal on git:master x [10:39:27]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make susp <span class="comment">#demo1</span></span></span><br><span class="line">cc     susp.c   -o susp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/humble/tmp/lhq/parallel/signal on git:master x [10:39:31]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./susp</span></span><br><span class="line">*****^C</span><br><span class="line">!^C!*****</span><br><span class="line">^\[1]    35672 quit (core dumped)  ./susp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/humble/tmp/lhq/parallel/signal on git:master x [10:40:23] C:131</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vi susp.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/humble/tmp/lhq/parallel/signal on git:master x [10:40:23] C:131</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make susp <span class="comment">#demo2</span></span></span><br><span class="line">cc     susp.c   -o susp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/humble/tmp/lhq/parallel/signal on git:master x [10:40:43]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./susp</span></span><br><span class="line">*****^C</span><br><span class="line">!****^C^C^C^C*^C^C^C^C^C^C</span><br><span class="line">!*^C****</span><br><span class="line">!**^\[1]    35836 quit (core dumped)  ./susp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/humble/tmp/lhq/parallel/signal on git:master x [10:41:11] C:131</span></span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2020/08/31/apue_76%E4%BF%A1%E5%8F%B7%E9%9B%86/">apue_76信号集</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://humble-zh.github.io/page/5/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2020-08-31T01:20:57.000Z" itemprop="datePublished">2020-08-31</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/apue/" rel="tag">apue</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="apue-76信号集"><a href="#apue-76信号集" class="headerlink" title="apue_76信号集"></a>apue_76信号集</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Filename: block.c</span></span><br><span class="line"><span class="comment"> * No.76.信号集</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * 每秒打印一个*，打印5个*就换行。中途收到1个或多个SIGINT(CTRL+C)信号暂不处理，等第5个*后只处理1个</span></span><br><span class="line"><span class="comment"> * Last modified: humble 20200404 10:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二选一</span></span><br><span class="line"><span class="comment">//#define demo0 (1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> demo1 (1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> demo0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SAVESET_ (1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SAVESET_ (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int_handler</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;!&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>, oset, saveset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;argc !=1&quot;</span>);</span><br><span class="line">        usage();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signal(SIGINT, int_handler);</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _SAVESET_</span></span><br><span class="line">    <span class="comment">//此句目的在于保存当前mask到saveset，方便以后恢复，用SIG_UNBLOCK或SIG_BLOCK都无所谓</span></span><br><span class="line">    sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, &amp;saveset);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//1.把当前的mask保存到oset内(方便以后恢复)，如果为NULL表示不保存</span></span><br><span class="line">        <span class="comment">//2.把set指定的信号阻塞住（即把mask的对应bit清零）</span></span><br><span class="line">        <span class="comment">//那么收到set指定的信号(padding对应bit被置一)，也不会被处理(因为 mask&amp;padding 中信号对应bit不为1)</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            write(<span class="number">1</span>, <span class="string">&quot;*&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> demo0</span></span><br><span class="line">        <span class="comment">//把set指定的信号取消阻塞住（即把mask的对应bit置一）</span></span><br><span class="line">        <span class="comment">//那么收到set指定的信号(padding对应bit被置一)，就会被处理(因为 mask&amp;padding 中信号对应bit为1)</span></span><br><span class="line">        <span class="comment">//问题：假如原本set指定的一或多个信号一开始就是BLOCK状态，那执行完下面这句它(们)就变为了UNBLOCK。</span></span><br><span class="line">        <span class="comment">//应该改为：原本是什么状态，最后又恢复到什么状态。定义_SAVESET_为1即可</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> demo1</span></span><br><span class="line">        <span class="comment">//1.把当前的mask保存到NULL内，也就是不保存</span></span><br><span class="line">        <span class="comment">//2.把mask设置为oset(相当于恢复了之前的状态)</span></span><br><span class="line">        <span class="comment">//那么收到oset指定的信号(padding对应bit被置一)，就会被处理(因为 mask&amp;padding 中信号对应bit为1)</span></span><br><span class="line">        <span class="comment">//另外，用oset好处是：原本是什么状态，最后又恢复到什么状态。则_SAVESET_不需要定义为1</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;oset, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _SAVESET_</span></span><br><span class="line">    <span class="comment">//把mask设置为saveset(相当于恢复了之前的状态)</span></span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;saveset, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USAGE <span class="meta-string">&quot;Usage:\n\</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">  Helloworld\n&quot;</span></span></span><br><span class="line">    <span class="built_in">printf</span>(USAGE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/humble/tmp/lhq/parallel/signal on git:master o [9:21:57]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make block</span></span><br><span class="line">cc     block.c   -o block</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/humble/tmp/lhq/parallel/signal on git:master x [9:22:02]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./block</span></span><br><span class="line">***^C**</span><br><span class="line">!*****</span><br><span class="line">**^\[1]    21111 quit (core dumped)  ./block</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> li @ evpower <span class="keyword">in</span> ~/humble/tmp/lhq/parallel/signal on git:master x [9:22:47] C:131</span></span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2020/08/19/ubuntu%E5%AE%89%E8%A3%85%E5%90%8E%E9%9C%80%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85/">ubuntu安装后需要做的事情</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://humble-zh.github.io/page/5/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2020-08-18T19:04:00.000Z" itemprop="datePublished">2020-08-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/ubuntu/" rel="tag">ubuntu</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="安装ubuntu后做的事情"><a href="#安装ubuntu后做的事情" class="headerlink" title="安装ubuntu后做的事情"></a>安装ubuntu后做的事情</h1><h2 id="删除不必要的软件"><a href="#删除不必要的软件" class="headerlink" title="删除不必要的软件"></a>删除不必要的软件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove libreoffice-common unity-webapps-common thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku landscape-client-ui-install onboard deja-dup</span><br></pre></td></tr></table></figure>
<h2 id="修改软件源为aliyun"><a href="#修改软件源为aliyun" class="headerlink" title="修改软件源为aliyun"></a>修改软件源为aliyun</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list</span><br><span class="line"><span class="comment">#sudo sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义DHCP网络的DNS-Server-IP地址"><a href="#自定义DHCP网络的DNS-Server-IP地址" class="headerlink" title="自定义DHCP网络的DNS Server IP地址"></a>自定义DHCP网络的DNS Server IP地址</h2><p>sudo vi /etc/dhcp/dhclient.conf 文件，在第21行#prepend domain-name-servers 127.0.0.1;下一行添加如下2行使用aliyun和114的DNS</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prepend domain-name-servers 114.114.114.114;</span><br><span class="line">prepend domain-name-servers 223.5.5.5;</span><br></pre></td></tr></table></figure>
<p>这样可以优先使用aliyun的dns，次要使用114的DNS。</p>
<h2 id="up-sh"><a href="#up-sh" class="headerlink" title="~/up.sh"></a>~/up.sh</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br><span class="line">apt-get dist-upgrade</span><br><span class="line"></span><br><span class="line">apt-get autoremove</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法一、如果你知道要删除软件的具体名称，可以使用</span></span><br><span class="line"><span class="comment">#sudo apt-get remove --purge 软件名称</span></span><br><span class="line"><span class="comment">#sudo apt-get autoremove --purge 软件名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#方法二、如果不知道要删除软件的具体名称，可以使用</span></span><br><span class="line"><span class="comment">#dpkg --get-selections | grep &#x27;软件相关名称&#x27;</span></span><br><span class="line"><span class="comment">#sudo apt-get purge 一个带core的package，如果没有带core的package，则是情况而定。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#清理残留数据</span></span><br><span class="line"><span class="comment">#dpkg -l |grep ^rc|awk &#x27;&#123;print $2&#125;&#x27; |sudo xargs dpkg -P</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#apt-get的卸载相关的命令有remove/purge/autoremove/clean/autoclean等。具体来说：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#apt-get purge / apt-get --purge remove</span></span><br><span class="line"><span class="comment">#删除已安装包（不保留配置文件)。</span></span><br><span class="line"><span class="comment">#如软件包a，依赖软件包b，则执行该命令会删除a，而且不保留配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#apt-get autoremove</span></span><br><span class="line"><span class="comment">#删除为了满足依赖而安装的，但现在不再需要的软件包（包括已安装包），保留配置文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#apt-get remove</span></span><br><span class="line"><span class="comment">#删除已安装的软件包（保留配置文件），不会删除依赖软件包，且保留配置文件。</span></span><br><span class="line"></span><br><span class="line">apt-get autoclean</span><br><span class="line"><span class="comment">#APT的底层包是dpkg, 而dpkg 安装Package时, 会将 *.deb 放在 /var/cache/apt/archives/中，apt-get autoclean 只会删除 /var/cache/apt/archives/ 已经过期的deb。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#apt-get clean</span></span><br><span class="line"><span class="comment">#使用 apt-get clean 会将 /var/cache/apt/archives/ 的 所有 deb 删掉，可以理解为 rm /var/cache/apt/archives/*.deb。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">######################</span></span><br><span class="line"><span class="comment">#那么如何彻底卸载软件呢？</span></span><br><span class="line"><span class="comment"># 删除软件及其配置文件</span></span><br><span class="line"><span class="comment">#apt-get --purge remove &lt;package&gt;</span></span><br><span class="line"><span class="comment"># 删除没用的依赖包</span></span><br><span class="line"><span class="comment">#apt-get autoremove &lt;package&gt;</span></span><br><span class="line"><span class="comment"># 此时dpkg的列表中有“rc”状态的软件包，可以执行如下命令做最后清理：</span></span><br><span class="line"><span class="comment">#dpkg -l |grep ^rc|awk &#x27;&#123;print $2&#125;&#x27; |sudo xargs dpkg -P</span></span><br><span class="line"><span class="comment">#当然如果要删除暂存的软件安装包，也可以再使用clean命令。</span></span><br><span class="line"><span class="comment">######################</span></span><br></pre></td></tr></table></figure>
<h2 id="交换Caps-Lock和Escape键"><a href="#交换Caps-Lock和Escape键" class="headerlink" title="交换Caps_Lock和Escape键"></a><a target="_blank" rel="noopener" href="https://askubuntu.com/questions/363346/how-to-permanently-switch-caps-lock-and-esc">交换Caps_Lock和Escape键</a></h2><p>方法1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dconf write /org/gnome/desktop/input-sources/xkb-options <span class="string">&quot;[&#x27;caps:escape&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>
<p>方法2:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.input-sources xkb-options <span class="string">&quot;[&#x27;caps:escape&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>
<p>方法3:<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yu-tao/p/8405528.html">ubuntu下交换Caps_Lock和Escape键的方法</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install dconf-tools</span><br><span class="line">dconf-editor</span><br></pre></td></tr></table></figure>
<p><code>org &gt;&gt; gnome &gt;&gt; desktop &gt;&gt; input-sources</code> 修改xkb-options为<code>[&#39;caps:swapescape&#39;]</code></p>
<h2 id="安装需要的软件"><a href="#安装需要的软件" class="headerlink" title="安装需要的软件"></a>安装需要的软件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vpnc git axel openssh-server exfat-fuse unrar unace rar zip unzip p7zip-full silversearcher-ag ctags exuberant-ctags tmux autojump curl jq sshpass net-tools scrot cloc fzf</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install g++ libncurses5-dev zlib1g-dev bison flex unzip autoconf gawk make gettext gcc binutils patch bzip2 libz-dev asciidoc subversion libssl-dev</span><br></pre></td></tr></table></figure>
<h2 id="安装typora"><a href="#安装typora" class="headerlink" title="安装typora"></a>安装<a target="_blank" rel="noopener" href="https://www.typora.io/#linux">typora</a></h2><h2 id="安装shutter"><a href="#安装shutter" class="headerlink" title="安装shutter"></a>安装shutter</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:linuxuprising/shutter</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install shutter</span><br></pre></td></tr></table></figure>
<h2 id="安装albert"><a href="#安装albert" class="headerlink" title="安装albert"></a>安装<a target="_blank" rel="noopener" href="https://software.opensuse.org/download.html?project=home:manuelschneid3r&package=albert">albert</a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i albert_0.16.1_amd64.deb</span><br><span class="line">sudo apt-get install -f</span><br></pre></td></tr></table></figure>
<h2 id="安装vim8"><a href="#安装vim8" class="headerlink" title="安装vim8"></a>安装vim8</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim --version <span class="comment">#如果已经是vim8那就跳#如果已经是vim8那就跳过此步</span></span><br><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure>
<h2 id="安装neovim"><a href="#安装neovim" class="headerlink" title="安装neovim"></a>安装<a target="_blank" rel="noopener" href="https://github.com/neovim/neovim/wiki/Installing-Neovim">neovim</a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install neovim</span><br></pre></td></tr></table></figure>
<p>16.04安装neovim</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudo add-apt-repository ppa:neovim-ppa/stable</span></span><br><span class="line">sudo add-apt-repository ppa:neovim-ppa/unstable</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y neovim</span><br><span class="line"><span class="comment"># pip3 install neovim</span></span><br></pre></td></tr></table></figure>
<p>设置默认编辑器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/vi vi /usr/bin/nvim 60</span><br><span class="line">sudo update-alternatives --config vi</span><br><span class="line">sudo update-alternatives --install /usr/bin/vim vim /usr/bin/nvim 60</span><br><span class="line">sudo update-alternatives --config vim</span><br><span class="line">sudo update-alternatives --install /usr/bin/editor editor /usr/bin/nvim 60</span><br><span class="line">sudo update-alternatives --config editor</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="选装"><a href="#选装" class="headerlink" title="选装"></a>选装</h2><h3 id="安装WPS"><a href="#安装WPS" class="headerlink" title="安装WPS"></a>安装WPS</h3><p>先到wps官网上下载wps的deb包。<a target="_blank" rel="noopener" href="http://www.wps.cn/product/">http://www.wps.cn/product/</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i wps-office_11.1.0.8722_amd64.deb</span><br></pre></td></tr></table></figure>
<p>解决字体冲突</p>
<p>下载symbol－fonts.deb<a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1dDxL7d3">点击去下载</a>并安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i symbol－fonts_1.1_all.deb</span><br></pre></td></tr></table></figure>
<h3 id="火狐安装插件"><a href="#火狐安装插件" class="headerlink" title="火狐安装插件"></a>火狐安装插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Tampermonkey(有些脚本在Greasemonkey无法运行)</span><br><span class="line">    AC-baidu:重定向优化百度搜狗谷歌必应搜索_favicon_双列</span><br><span class="line">    【玩的嗨】VIP工具箱,全网VIP视频免费破解去广告,一站式音乐搜索下载,获取B站封面,下载B站视频,上学吧答案获取等众多功能聚合</span><br><span class="line">    百度网盘直链满速下载助手</span><br><span class="line">    网盘自动填写访问码【威力加强版】</span><br><span class="line">    豆瓣资源下载大师：1秒搞定豆瓣电影|音乐|图书下载</span><br><span class="line">    持续更新 CSDN广告完全过滤、人性化脚本优化：不用再登录了！让你体验令人惊喜的崭新CSDN</span><br><span class="line">购物党实时比价工具(浏览器57以上版本安装)</span><br><span class="line">Adblock Plus - 免费的广告拦截器</span><br><span class="line">Vedio Speed Controller</span><br><span class="line">Vimium C 全键盘操作浏览器</span><br><span class="line">划词翻译  有道</span><br><span class="line">京价保 - 京东价保助手</span><br><span class="line">Video Downloader Pro  免费视频下载器</span><br><span class="line">网页截图</span><br><span class="line">Gesturefy  鼠标手势操作</span><br><span class="line">markdown-clipper 网页保存为markdown</span><br></pre></td></tr></table></figure>

<h3 id="vim-neovim配置-vimrc与插件安装"><a href="#vim-neovim配置-vimrc与插件安装" class="headerlink" title="vim/neovim配置.vimrc与插件安装"></a><a target="_blank" rel="noopener" href="https://github.com/humble-zh/myvim">vim/neovim配置.vimrc与插件安装</a></h3><h3 id="安装经典菜单指示器"><a href="#安装经典菜单指示器" class="headerlink" title="安装经典菜单指示器"></a>安装经典菜单指示器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:diesch/testing</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install classicmenu-indicator</span><br></pre></td></tr></table></figure>
<h3 id="安装系统指示器SysPeek"><a href="#安装系统指示器SysPeek" class="headerlink" title="安装系统指示器SysPeek"></a>安装系统指示器SysPeek</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:nilarimogard/webupd8</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install syspeek</span><br></pre></td></tr></table></figure>
<h3 id="安装网页flashplayer"><a href="#安装网页flashplayer" class="headerlink" title="安装网页flashplayer"></a>安装网页flashplayer</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install flashplugin-installer</span><br></pre></td></tr></table></figure>
<h3 id="系统设置——外观——行为——开启工作区-amp-添加“显示桌面”图标到启动器"><a href="#系统设置——外观——行为——开启工作区-amp-添加“显示桌面”图标到启动器" class="headerlink" title="系统设置——外观——行为——开启工作区 &amp; 添加“显示桌面”图标到启动器"></a>系统设置——外观——行为——开启工作区 &amp; 添加“显示桌面”图标到启动器</h3><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sudo apt-get install software-properties-common -y</span></span><br><span class="line"><span class="comment">#sudo add-apt-repository ppa:max-c-lv/shadowsocks-libev -y</span></span><br><span class="line"><span class="comment">#sudo apt-get update</span></span><br><span class="line">sudo apt install shadowsocks-libev</span><br><span class="line">sudo vi /etc/shadowsocks-libev/v2ray.conf</span><br><span class="line"></span><br><span class="line">sudo apt-get install proxychains</span><br><span class="line">sudo vi /etc/proxychains.conf <span class="comment">#改为 socks5 	127.0.0.1 1080</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">oyvpn</span></span>()&#123;</span><br><span class="line">    pidof ss-local &amp;&amp; &#123; <span class="built_in">echo</span> <span class="string">&quot;oyvpn is aready runing&quot;</span>; <span class="built_in">return</span>; &#125;</span><br><span class="line">    nohup ss-local -c /etc/shadowsocks-libev/v2ray.conf &amp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="终端效率"><a href="#终端效率" class="headerlink" title="终端效率"></a>终端效率</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install i3</span><br><span class="line">sudo apt-get install pcmanfm</span><br><span class="line"><span class="comment"># 注销，选i3，重新登陆</span></span><br><span class="line"><span class="built_in">cd</span> $(blogdir)</span><br><span class="line">mv ~/.config/i3/config ~/.config/i3/config.bak</span><br><span class="line">ln -s $(<span class="built_in">pwd</span>)/<span class="built_in">source</span>/_posts/ubuntu安装后需要做的事情/config ~/.config/i3/config</span><br><span class="line">sudo mv /etc/i3status.conf /etc/i3status.conf.bak</span><br><span class="line">sudo ln -s $(<span class="built_in">pwd</span>)/<span class="built_in">source</span>/_posts/ubuntu安装后需要做的事情/i3status.conf /etc/i3status.conf</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://ohmyz.sh/">on-my-zsh</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zsh git</span><br><span class="line"><span class="comment"># chsh -s /bin/zsh</span></span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)</span>&quot;</span></span><br><span class="line"><span class="built_in">cd</span> $(blogdir)</span><br><span class="line">mv ~/.zshrc ~/.zshrc.bak</span><br><span class="line">ln -s $(<span class="built_in">pwd</span>)/<span class="built_in">source</span>/_posts/ubuntu安装后需要做的事情/zshrc ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>如果出现 <code>Failed to connect to raw.githubusercontent.com port 443: Connection refused</code> ,就在/etc/hosts文件追加</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">199.232.28.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md">zsh-syntax-highlighting</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md#oh-my-zsh">zsh-autosuggestions</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://inkscape.org/">inkscape</a>: 编辑图片画框画箭头等等</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ggreer/the_silver_searcher">the_silver_searcher</a>: 快速的代码命令行搜索工具 ag</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yucicheung/article/details/80058338">tmux</a>: 终端分屏工作（目前少用）</p>
<p><a target="_blank" rel="noopener" href="https://github.com/tmux-python/tmuxp">tmuxp</a>: 终端分屏工作（目前未用）</p>
<p><a target="_blank" rel="noopener" href="https://github.com/wting/autojump">autojump</a>: 快速跳转目录</p>
<p><a target="_blank" rel="noopener" href="http://cloc.sourceforge.net/">cloc</a>: 统计代码行数，可区分文件类型以及空行和注释</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;. /usr/share/autojump/autojump.sh&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/junegunn/fzf">fzf</a>: 终端命令行模糊查询历史</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译依赖go，请提前安装</span></span><br><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/junegunn/fzf.git ~/.fzf</span><br><span class="line">~/.fzf/install</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install fzf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;[ -f ~/.fzf.bash ] &amp;&amp; source ~/.fzf.bash&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/tldr-pages/tldr">tldr</a>: TLDR 页的 GitHub 仓库将其描述为简化的、社区驱动的手册页集合。too long didn’t read</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g tldr</span><br><span class="line">sudo pip3 install tldr</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/jakubroztocil/httpie">httpie</a>: HTTPie 是一个 HTTP 的命令行客户端<br>~/.bashrc 文件末尾追加内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> jev3=<span class="string">&#x27;cd ~/humble/ev345/ &amp;&amp; ctags -R package/libevpower/ package/chrgrserv/ package/dashboard/&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> jcs=<span class="string">&#x27;cd ~/humble/ev345/package/chrgrserv/src/&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> jlev=<span class="string">&#x27;cd ~/humble/ev345/package/libevpower/src/&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> jblog=<span class="string">&#x27;cd ~/humble/blog/source/_posts/&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> jtools=<span class="string">&#x27;cd ~/humble/tools/ &amp;&amp; . venv/bin/activate&#x27;</span></span><br><span class="line">. /usr/share/autojump/autojump.sh</span><br><span class="line">[ -f ~/.fzf.bash ] &amp;&amp; <span class="built_in">source</span> ~/.fzf.bash</span><br></pre></td></tr></table></figure>
<h3 id="安装go"><a href="#安装go" class="headerlink" title="安装go"></a>安装go</h3><p>16.04安装go 1.6版本 <code>sudo apt install golang-go</code> (太旧了)</p>
<p><a target="_blank" rel="noopener" href="https://github.com/golang/dep/issues/1985#issuecomment-436897443">安装新版本</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge golang*  <span class="comment"># 卸载旧版1.6</span></span><br><span class="line">sudo rm -rf /usr/lib/go-1.6/ /usr/lib/go-1.6/src/ /usr/lib/go-1.6/src/runtime/ /usr/lib/go-1.6/src/runtime/race</span><br><span class="line">curl -O https://dl.google.com/go/go1.17.1.linux-386.tar.gz</span><br><span class="line">tar -C /usr/<span class="built_in">local</span> -xzf go1.17.1.linux-386.tar.gz</span><br><span class="line"><span class="comment"># 给 /etc/environment 的PATH添加 “:/usr/local/go/bin&quot; 后注销重新登陆</span></span><br><span class="line">go env  <span class="comment"># 检测安装成功</span></span><br></pre></td></tr></table></figure>
<p>使用国内代理安装go模块速度快(参考<a target="_blank" rel="noopener" href="https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md">https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md</a>)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>
<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p><a target="_blank" rel="noopener" href="https://github.com/joh/when-changed">when-changed</a>: 监控文件变动并且执行命令</p>
<p>ipdb:pip3 install ipdb</p>
<p>删除启动项:sudo efibootmgr -b 0001 -B</p>
<h2 id="ubuntu16-04和win时间不同步"><a href="#ubuntu16-04和win时间不同步" class="headerlink" title="ubuntu16.04和win时间不同步"></a>ubuntu16.04和win时间不同步</h2><p>先在ubuntu下更新一下时间，确保时间无误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ntpdate</span><br><span class="line">sudo ntpdate time.windows.com</span><br></pre></td></tr></table></figure>
<p>然后将时间更新到硬件上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hwclock --localtime --systohc</span><br></pre></td></tr></table></figure>
<p>重新进入windows10，发现时间恢复正常了！</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2020/07/31/ubuntu16.04%E6%90%AD%E5%BB%BAJAVA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">ubuntu16.04搭建JAVA开发环境</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://humble-zh.github.io/page/5/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2020-07-31T01:21:54.000Z" itemprop="datePublished">2020-07-31</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/java/" rel="tag">java</a>, <a class="article-tag-link" href="/tags/ubuntu/" rel="tag">ubuntu</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="安装openjdk8"><a href="#安装openjdk8" class="headerlink" title="安装openjdk8"></a>安装openjdk8</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install openjdk-8-jdk openjdk-8-jre</span><br></pre></td></tr></table></figure>
<p>用<code>java -version</code>确认安装成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openjdk version &quot;1.8.0_252&quot;</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_252-8u252-b09-1ubuntu1-b09)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.252-b09, mixed mode)</span><br></pre></td></tr></table></figure>
<p>配置 JAVA_HOME 和 JRE_HOME 环境变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; /etc/environment &lt;&lt;EOL</span><br><span class="line">JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</span><br><span class="line">JRE_HOME=/usr/lib/jvm/java-8-openjdk-amd64/jre</span><br><span class="line">EOL</span><br></pre></td></tr></table></figure>
<p>注销或重启系统，用<code>javac -version</code>确认<code>javac 1.8.0_252</code>环境配置成功</p>
<h1 id="安装idea"><a href="#安装idea" class="headerlink" title="安装idea"></a>安装idea</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo cp ~/下载/ideaIU-2020.1.tar.gz /usr/local/src</span><br><span class="line">cd /usr/local/src</span><br><span class="line">sudo tar -zxvf ideaIU-2020.1.tar.gz</span><br><span class="line">sudo cp ~/下载/jetbrains-agent.jar /usr/local/src/idea-IU-201.6668.121</span><br><span class="line">cd /usr/local/src/idea-IU-201.6668.121/bin</span><br><span class="line">sudo ./idea.sh</span><br></pre></td></tr></table></figure>
<p><code>Do not import settings</code> - <code>OK</code></p>
<p><code>Accept</code></p>
<p><code>Evaluate for free</code> - <code>Evaluate</code></p>
<p><code>选择UI主题</code> - <code>Next</code></p>
<p><code>Create a destop entry for ...</code> - <code>For all users...</code> - <code>Next</code></p>
<p><code>Create a script for opening ...</code> - <code>Next</code></p>
<p><code>Default plugins</code>不选 - <code>Next</code></p>
<p><code>Featured plugins</code>不选 - <code>Next</code></p>
<p>如果上面的没出现，可以点<code>Welcome</code>窗口右下角<code>Configure</code> - <code>Restore Default Settings</code></p>
<h1 id="激活idea"><a href="#激活idea" class="headerlink" title="激活idea"></a>激活idea</h1><p>启动idea，<code>Help</code> - <code>Edit Custom VM Options...</code></p>
<p>追加一行<code>-javaagent:/usr/local/src/idea-IU-201.6668.121/jetbrains-agent.jar</code></p>
<p><code>cat ~/下载/ACTIVATION_CODE.txt</code>，拷贝该激活码</p>
<p>重启idea，<code>Help</code> - <code>Register...</code> - <code>activation code</code> - <code>粘贴激活码</code> - <code>Activation</code></p>
<p>如果不行，尝试修改<code>/usr/local/src/idea-IU-201.6668.121/</code>整个目录的权限为<code>755</code></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2020/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://humble-zh.github.io/page/5/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2020-06-04T06:05:29.000Z" itemprop="datePublished">2020-06-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="iNode介绍"><a href="#iNode介绍" class="headerlink" title="iNode介绍"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17J41147a8">iNode介绍</a></h2><iframe src="//player.bilibili.com/player.html?aid=80114460&bvid=BV17J41147a8&cid=137104085&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">【小知识】第12期 linux中的iNode介绍</iframe>

<h2 id="cron"><a href="#cron" class="headerlink" title="cron"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19t411G7KU">cron</a></h2><iframe src="//player.bilibili.com/player.html?aid=59477168&bvid=BV19t411G7KU&cid=103631657&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">【cron定时脚本】定时执行程序的cron了解一下</iframe>

<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1av411q73F">死锁</a></h2><iframe src="//player.bilibili.com/player.html?aid=243961921&bvid=BV1av411q73F&cid=213797012&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">花三分钟了解一下死锁 | 这波不亏，不亏</iframe>

<p>死锁必须同时满足4个条件(破坏任意一个即可)：</p>
<ol>
<li>互斥使用：资源被一个任务使用时，别的任务不能使用（一般不破坏这个条件）</li>
<li>不可抢占：请求者不能强制从占有者手中夺取资源（任务拿到资源1时却拿不到资源2就主动释放所有已占有的资源）</li>
<li>占有且等待：请求其他资源的同时保持对原有资源的占有（每个任务一次申请所有的资源，失败就阻塞等待）</li>
<li>循环等待：任务一等待任务二释放资源，二又等一释放（给所有资源设定序号，每个任务都从需要小的资源开始申请）</li>
</ol>
<h2 id="线程-协程-异步的编程模型"><a href="#线程-协程-异步的编程模型" class="headerlink" title="线程/协程/异步的编程模型"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1S4411Z7M2">线程/协程/异步的编程模型</a></h2><iframe src="//player.bilibili.com/player.html?aid=64066246&bvid=BV1S4411Z7M2&cid=111239761&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">【小知识】第5期 线程/协程/异步的编程模型</iframe>

<h2 id="IO多路复用select-poll-epoll介绍"><a href="#IO多路复用select-poll-epoll介绍" class="headerlink" title="IO多路复用select/poll/epoll介绍"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1qJ411w7du">IO多路复用select/poll/epoll介绍</a></h2><iframe src="//player.bilibili.com/player.html?aid=68126222&bvid=BV1qJ411w7du&cid=118080873&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">【并发】IO多路复用select/poll/epoll介绍</iframe>

<p>select:使用文件描述符</p>
<ol>
<li>1024 bitmap</li>
<li>FD_SET设置好的bitmap不可重用</li>
<li>bitmap从用户态拷贝到内核态的开销</li>
<li>发生事件select返回后，需要O(n)遍历全部bitmap才能知道发生了哪些事情</li>
</ol>
<p>poll:使用struct pollfd{fd,events,revents}</p>
<ol>
<li>内核使用链表存储，不止1024(events和revents时short有65535个bit)</li>
<li>关心事件bitmap(events)和发生事件(revents)分开，使得bitmap可重用</li>
<li>同select</li>
<li>同select</li>
</ol>
<p>epoll:使用struct epoll_event{data.fd,events}</p>
<ol>
<li>内核使用红黑树存储，但没有revents</li>
<li>epoll_ctl添加关心事件到内核态（可重用）</li>
<li>第2步已经拷贝到内核态，一次拷贝，终生受用，降低开销(视频有误：实际没有使用共享内存)</li>
<li>poll_wait直接把发生事件回填到参数内不需要再遍历判断</li>
</ol>
<h2 id="float是如何在计算机中存储的"><a href="#float是如何在计算机中存储的" class="headerlink" title="float是如何在计算机中存储的"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1F741137za">float是如何在计算机中存储的</a></h2><iframe src="//player.bilibili.com/player.html?aid=89068376&bvid=BV1F741137za&cid=152134800&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">【小知识】float是如何在计算机中存储的</iframe>

<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1xJ411p7ot">信号</a></h2><iframe src="//player.bilibili.com/player.html?aid=83003758&bvid=BV1xJ411p7ot&cid=141997484&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">【linux】信号-进程间通信的方式</iframe>

<h2 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16J411p7f1">用户态与内核态</a></h2><iframe src="//player.bilibili.com/player.html?aid=83047145&bvid=BV16J411p7f1&cid=142069425&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">【linux】10分钟搞懂用户态与内核态</iframe>

<p>用户态 申请外部资源（系统调用，中断，异常）后会陷入到内核态</p>
<h2 id="操作系统的内存管理简介"><a href="#操作系统的内存管理简介" class="headerlink" title="操作系统的内存管理简介"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1u7411z7Sv">操作系统的内存管理简介</a></h2><iframe src="//player.bilibili.com/player.html?aid=85489309&bvid=BV1u7411z7Sv&cid=146128170&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">【OS】操作系统的内存管理简介</iframe>

<h2 id="nginx反向代理与负载均衡教程"><a href="#nginx反向代理与负载均衡教程" class="headerlink" title="nginx反向代理与负载均衡教程"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Bx411Z7Do">nginx反向代理与负载均衡教程</a></h2><iframe src="//player.bilibili.com/player.html?aid=58516750&bvid=BV1Bx411Z7Do&cid=102055911&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">【nginx入门】nginx反向代理与负载均衡教程</iframe>
        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
</nav>



            </div>
        </div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?e4027971a230b210f4671f485b33846a";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
    
</footer>

    </main>

    <script type="text/javascript" src="https://unpkg.com/jquery@1.9.1/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }

            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle('normal', slideDone);
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp('normal', slideDone);
            }, 3000);
        }

        function slideDone() {
            if (nodes.navInner.css('display') !== 'none') {
                nodes.navInner.css('display', '');
            }
        }

        $(window).on('resize', function() {
            if ($(this).width() > 960) {
                nodes.navInner.css('display', '');
            }
        });
    });
    </script>
    

</body>
</html>
